<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hi, Thinking</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://arstead.github.io/"/>
  <updated>2017-05-05T07:06:57.209Z</updated>
  <id>https://arstead.github.io/</id>
  
  <author>
    <name>Kivi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《恶意》 东野圭吾 著</title>
    <link href="https://arstead.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%82%AA%E6%84%8F/"/>
    <id>https://arstead.github.io/读书笔记/悪意/</id>
    <published>2017-05-02T06:50:22.000Z</published>
    <updated>2017-05-05T07:06:57.209Z</updated>
    
    <content type="html"><![CDATA[<p><small><em>总字数：约38字，阅读时间：约7分钟</em></small></p>
<blockquote>
<p>高傲者对卑微者的轻蔑，在地位对换后突变为不甘的怨恨。襁褓中的恶意在嫉妒的培育下，悄声扭曲人的心灵。   —Kivi</p>
</blockquote>
<p>东野圭吾的小说读起来总是让人没有任何的压迫感，简洁的文字中透露着小说世界中的每一丝细节。阅读时，我们只需要让故事牵引着我们的思绪，让自己沉浸在东野圭吾所创造的环境之中，时而紧张，时而疑惑，时而思考，时而释然，每个时刻的心绪都已被完美的设计。任由自己完全跟随书中的指引，来探索这片他人创建的森林。伴随着最后的句点，踏出这片森林，回归现实世界，依旧忘不了旅途中的精彩。</p>
<h4 id="写作手法"><a href="#写作手法" class="headerlink" title="写作手法"></a>写作手法</h4><p>首先要提的是这本书的写作手法，刚开始看到每一章的标题时，并没有理解其所要表达的意思。以为这是一本以野野口修为第一视角写的一本侦探小说。但是当我看到了加贺手记之后，才发现自己完全是处于一个警察的角度在审视整个过程。就连刚开篇的描述，也不过是罪犯自我掩饰的证据罢了。这种书信的写作手法很容易让人直接代入到故事中，让读者完全沉静其中，仿佛自己是亲临现场一般。</p>
<h4 id="案件本身"><a href="#案件本身" class="headerlink" title="案件本身"></a>案件本身</h4><p>或许整本的推理过程并没有让我觉得太惊艳的地方。在阅读的过程中，很多奇怪的细节读者都能把握，例如在事件中野野口修对警察的提示，让其不要动相关的书籍；在行凶未遂之后，号称深爱初美的野野口修竟然真的走了，留下初美跟日高独处；即使是在初美死后，野野口修依旧以威胁为由继续担当日高的影子作家。案件的本身确实存在相当多的疑点，但是这些看似疑点的地方却也不能能改变案件本身的性质。毕竟野野口修已经承认了自己是凶手，而且在加贺的调查之下，也找到了合理的犯罪动机。一切似乎看上去相当正常，即使是单纯的这样定罪，似乎没有任何一个人会觉得这里面藏有什么秘密。故事到这里，作为侦探小说的基本使命已经达到了，我们已经感受到了解开谜题的乐趣，窥视了一个人走上犯罪道路的心路历程，逻辑推理上看似有所遗漏但是也能够完全解释的通。故事看到这里，我感觉一切都已经结束了。但是，一切似乎远没有我想象的那么简单。东野圭吾的小说，永远能在意料之外给人带来惊喜。</p>
<p>回忆起整个案件，所有的点点滴滴都完美的衔接在了一次，每一处细节都有了其合理的解释。从野野口修的手记开始，让我们一点点步入这个完美的虚拟世界。</p>
<p>作为作家的野野口修，在自己好友日高邦彦被谋杀之后，决定用自己的文字将这起凶杀案记录下来，文章的起点，就是他最后一次前往日高的住所。著名小说家日高邦彦次日要离开日本，去往温哥华。所以日高约野野口修到自己家中做最后的离别交谈。在野野口到日高家时，遇到了他隔壁的邻居在窥视日高家。等到日高回到家后，他表示那个邻居在找日高杀死他们家猫的证据。因为邻居家的猫经常到他们家捣乱，他为此还给家里装了隔猫桩。而且日高表示，实际上猫确实是他杀的，在肉丸子里面下了点药毒死的。此时的日高家中，基本上都已经收拾完整，除了电话和电脑还保留着，因为他还需要最后加工赶完连载的稿子而他的妻子将会。而此时藤尾美弥子小姐为了日高所写小说《禁猎地》中侵犯其哥哥藤尾哉正隐私的问题进行谈判。而此时，野野口也起身辞别。回家后，野野口的出版社编辑来找他要稿子，两个人闲谈之中，野野口接到了一通来自日高的电话，要其八点到日高住所。与编辑一并到餐厅用过晚餐后，野野口去往日高的家中。到达时，看到其家中没有任何亮光，感觉异常的野野口修打电话给其妻子并在附近等待其妻子，两人一起进入房间后，发现日高已经死在地上，脑后被钝器击中，并且喉部有被勒过的痕迹。</p>
<p>实际上，整个凶杀案的嫌疑人只有两个，藤尾美弥子和野野口修。</p>
<p>加贺在自己的刑侦记录中记录下了自己是如何开始怀疑野野口修的，从犯案时间到犯案过程，最大的嫌疑人就是野野口修。实际上，加贺认为，曾经的同事野野口修连记录这起案件的意图，都是为了迷惑警察。但是，故事实际上这个时候才开始。搜查出决定性的证据之后，加贺拘留了野野口。野野口也为自己所犯下的罪行供认不讳。但是，却一直不肯告诉加贺，犯罪动机是什么，加贺只好自己去调查。</p>
<p>在对野野口家的仔细搜查之后，发现野野口家中有近乎所有日高所写小说的手稿，加贺又开始对野野口进行询问，他依旧闭口不言，只说这些手稿是他为了向日高学习而做的模仿练习。在继续的搜查中，加贺找到了一张女士照片，一个女士围裙以及一份未出行的旅游申请表。其中这位女子的是日高的前妻，日高初美，五年前意外死于车祸。面对这些证据，加贺回访了日高现任妻子日高理惠，并得知野野口曾对其表示初美的死并不是意外。加贺在与理惠的交谈中得知，野野口曾经特别嘱咐理惠在行李之中有一卷录像带，让她在行李寄回之后跟他说。当加贺拿到这卷录像带之后，所有的事情都豁然开朗了。这卷录像带记录的是一次入室事件，而地点就是日高的家，入室的人，正是野野口修。</p>
<p>在野野口修的记录中，清晰的描述了整个事件的起因。野野口修跟日高儿时是同学，他们两个都有一个共同的梦想，希望能成为作家。但是日高成为最终走上了作家之路，而野野口修则成为了教师。七年前，一次偶然的机会，野野口修遇到了正处于事业瓶颈期的日高。抓住这次机遇，野野口修将自己的作品给日高，希望能通过他帮助发表，但是日高却各种借口拖延。在去日高家交谈的过程中，野野口修与日高初美一见钟情，开始发展地下恋情。而初美透露，日高并不十分欣赏野野口修的作品，想占为己有。在这种困窘的处境下，初美和野野口修合谋想杀掉日高。他们两个一起密谋了一次杀人行动，初美给日高下安眠药，然后野野口修携带凶器进入日高家中，将日高杀害。谁知计划泄露，日高并没有睡着，而且野野口修入室的过程被花园中的摄像机记录下来，并且日高夺走了满是野野口修指纹的凶器，一把匕首。由此，日高开始以这个为威胁，要求野野口修作为其影子作家，在幕后帮助其写连载小说。而在野野口修家中发现的手稿，就是他为日高所写的初稿。五年前，初美由于车祸死亡，但是野野口修认为是日高所为，但是被抓住把柄的野野口修却无法反抗。直至这次，日高打算去往国外，日高承诺离国之后将彻底释放他。但是野野口修知道日高并不会就此放过他，所以他决定杀了他。</p>
<p>至此，整起杀人案件似乎已经水落石出。合理的犯罪动机，完整的犯罪过程以及不可置疑的物证。显然，这是一起由于胁迫而产生的犯罪事件。社会的矛头直至日高，用卑劣的手段胁迫他人作为自己的影子作家，抢夺别人的劳动果实，占据别人应有的光环。日高原有的书迷也开始倒戈，恶意攻击日高。</p>
<p>正如开头所言，故事到此，已经完整了展现了一场悲痛淋漓的犯罪事件，我们为野野口修感到惋惜，在错误的时间遇到了相爱的人，拥有了追求幸福的勇气却与天堂失之交臂，最后坠入邪恶笼罩的地狱。我们也为日高感到悲痛，昔日的好友为名为利为做出如此卑劣的事情。杀人动机的浮现让我们开始思考凶手和死者，到底谁代表正义，谁才是邪恶。</p>
<p>人性最深的恶意，不是来自于对错误的指责，而是来自对成功的嫉妒。或许，东野圭吾在这点上，理解的远比平常人要透彻。正如J·K·罗琳在《哈利波特》系列作品中所写，“其实我们容易宽恕别人的错误，却很难原谅别人的正确。”</p>
<p>满含这各种疑点，加贺认为这起案件依旧存在相当多不能解释的问题。所以加贺选择继续探究这件事情。他走访了野野口修和日高的儿时的同学，了解他们儿时的关系。加贺走访了日高出本的小说《死火》所描述的那个烟火师，了解到曾经确实有一个小孩经常默不作声的观看他制作烟火。在走访同学时，了解了他们在遭遇校园暴力时的情况，询问了当时藤尾哉正在强奸邻校少女时的状况。看完《禁猎地》的加贺一直认为，这本书中所描述的经常被人欺负的主角是作者本人，也就是最开始认为是日高。但是在野野口修口中，加贺知道，野野口修才是这本书的主角。那么，被欺负的人实际上就是野野口修。儿时的事情已经过去很久，大家的描述也都模糊不清。但是，走访了所有情况之后，加贺却发现了一个让人不寒而栗的假设。</p>
<p>事实上，野野口修确实是真凶，不过他伪造的不是犯罪事实，而是犯罪动机。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;small&gt;&lt;em&gt;总字数：约38字，阅读时间：约7分钟&lt;/em&gt;&lt;/small&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;高傲者对卑微者的轻蔑，在地位对换后突变为不甘的怨恨。襁褓中的恶意在嫉妒的培育下，悄声扭曲人的心灵。   —Kivi&lt;/p&gt;
&lt;/blockquote
    
    </summary>
    
      <category term="读书笔记" scheme="https://arstead.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://arstead.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《东方快车谋杀案》 阿加莎·克里斯蒂 著</title>
    <link href="https://arstead.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Murder_on_the_Orient_Express/"/>
    <id>https://arstead.github.io/读书笔记/Murder_on_the_Orient_Express/</id>
    <published>2017-04-29T03:50:55.000Z</published>
    <updated>2017-05-05T07:22:26.989Z</updated>
    
    <content type="html"><![CDATA[<p><small><em>总字数：约38字，阅读时间：约7分钟</em></small></p>
<blockquote>
<p>或许这本书的精华之处，不在于故事情节的环环相扣，不在于揭晓答案时的畅快淋漓，而在于结尾处，我们对公平和正义的思量。一个穷凶极恶的罪犯被杀了，凶手是否应该接受法律的裁决。或许，上个世纪大家都相信，正义才是关键，但是却没有人思考过，平等才是正义的源点。   —Kivi</p>
</blockquote>
<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>这段时间特别迷恋侦探小说，在逛书评的时候无意间看到了这本《东方快车谋杀案》，被称之为“侦探小说之后”阿加莎·克里斯蒂的最杰出与最著名的作品。这本书的语言简单，相较于现代小说而言，没有过多的细节描写和感情分析，阅读起来十分轻松。当然，犯案手法也并没有太出人意料的地方，毕竟是上个时代的作品。但是，这本书最让我觉得惊艳的地方不在于它的情节或是描写，而在于他最后向我们传达的正义。</p>
<a id="more"></a>
<h4 id="阿姆斯特朗绑架案"><a href="#阿姆斯特朗绑架案" class="headerlink" title="阿姆斯特朗绑架案"></a>阿姆斯特朗绑架案</h4><p>这是一起凶残的绑架案，绑匪将阿姆斯特朗上校的女儿黛西·阿姆斯特朗绑票，向阿姆斯特朗夫妇索取赎金。爱女心切的阿姆斯特朗夫妇交完赎金之后，绑匪依旧残忍的将黛西杀害。而这件事所引发的连锁反应，黛西的母亲因怀孕时郁郁寡欢而产下死婴，自己也随即死亡。而其父亲阿姆斯特朗上校也应亡妻丧女之痛而饮弹自尽。最后，由于受到警方的怀疑，无辜的女仆波莱特由于无法承受这样的压力而跳楼自杀了，一起绑架事件带走了五条人命。绑架案的凶手被绳之以法，但是幕后的主谋却逃之夭夭。五年后，在东方快车之上，一起看似简单的谋杀案，却跟阿姆斯特朗绑架案有着千丝万缕的联系。</p>
<h4 id="东方快车"><a href="#东方快车" class="headerlink" title="东方快车"></a>东方快车</h4><p>为了解决案件，侦探赫丘里·波洛临时需要搭乘东方快车回伦敦。在去往火车始发地的轮船上，他遇到了昔日好友，东方快车的董事长比安奇·布克先生。在用餐时的交谈时，布克先生表示这个时期的东方快车一定能买的上车票。倒也奇怪，在布克先生让仆人去帮其准备车票的时候，发现车票全都出售了。大家好像都不约而同的选择了这个时间出去旅行。布克先生动用自己作为董事长的身份，强行帮他安排了一个位置。而与他们同一个车厢的，有美国富商山缪·爱德华·雷切特，雷切特的秘书赫克特·麦奎恩，雷切特的贴身男仆爱德华·贝多斯，巴格达教师玛丽·德贝汉，英国陆军军官阿巴思诺特上校，俄国公主纳塔莉娅·德拉戈米罗夫，公主的女仆希尔德加德·施密特，匈牙利外交官鲁道夫·安德烈公爵及其妻子艾莲娜·安德烈公爵夫人，传教士格丽塔·欧尔森，准备返回美国的哈里埃特·贝琳达·哈巴德夫人，意大利汽车推销员吉诺·斯卡雷里，伪装了身份的美国侦探塞卢斯·迪克·哈德曼，以及车厢乘务员皮埃尔·米歇尔。火车就此出发。</p>
<p>第一天的中午雷切特在午餐时找到波洛，向其表示他收到了恐吓信，有人打算谋杀他，希望雇佣波洛作为其贴身保镖。作为侦探的波洛对于这样的案件并无兴趣，辞谢了雷切特的请求。</p>
<p>在当天的晚上，十二点三十七分时，一声响声，波洛被隔壁的雷切特吵醒，乘务员前去敲门查看，里面传来一句法语“只是做了个噩梦”。而其隔壁的哈巴德夫人急促的按铃声使得乘务员转而去向哈巴德夫人的车厢，哈巴德夫人表示她屋里刚刚有一个男人偷偷进来，她吓的不敢吱声，但是乘务员并没有看到有任何人离开，他认为是哈巴德夫人做了个噩梦，安抚了她一下就走了。深夜里，波洛有被一个声音吵醒，他悄悄的打开房门，看到过道中一个穿着猩红色睡衣的女子的背影走了过去。他并没有过多的在意。</p>
<p>第二天，雷切特的仆人去找雷切特，发现车厢门反锁。用乘务员的钥匙开锁后，发现门链也被扣上了。在强行将门打开之后，发现雷切特躺在床上，身上有十二处伤痕不一致的刀伤。而在夜间，火车也因为暴风雪而无法前行。</p>
<h4 id="谋杀案"><a href="#谋杀案" class="headerlink" title="谋杀案"></a>谋杀案</h4><p>随车医生康斯坦丁检验死者的死亡时间在头天晚上的凌晨十二点至两点。现场留有一根烟斗通条，一张被烧为灰烬的纸张，一张绣有“H”字样的亚麻手帕和一块被击碎的怀表，怀表上的时间停在了十二点三十七分。</p>
<p>通过烧过的纸张，波洛发现上面写着黛西·阿姆斯特的字样。他发现雷切特的真实身份是当年阿姆斯特朗绑架案的主谋卡塞蒂。故事由此开始变得精彩起来，看似一起简单杀人案，实则是一起对五年前绑架者的报复。由此开始，波洛侦讯了这届车厢的每一个人。</p>
<p>在侦讯的过程中，麦奎因表示卡塞蒂不会说法语，哈巴德夫人在自己的车厢中找到了一个列车服的纽扣，而没有任何一个列车员的衣服上缺失纽扣。而在检查施密特时，在她的行李箱中出现了一件少了一个纽扣的列车服，口袋里还有一把能开所有车厢们的钥匙。而此之后，哈巴德夫人又在自己的洗漱包中发现了一把沾满血迹的匕首。似乎一切证据都表明曾经有一个人伪装成列车员偷偷上了火车，在十二点三十七分的时候，杀害了卡塞蒂，并伪装成他回复了列车员，然后将凶器和服装都留在车上之后下车逃跑了。但是，在波洛眼里，依旧有很多问题解释不通，为什么十二处的刀伤会出现不一致的现象，有些伤痕已经深入肌肉，有的伤痕又像轻轻的划了一道，看上去作案的并不知道一个人，倒像是一男一女所谓。其次，绣有“H”的亚麻手帕到底是谁的？名字中带有H首字母的女士仅有施密特，哈巴德夫人，德贝纳姆小姐，但是女仆并不会使用这么昂贵精致的手帕，德贝纳姆小姐的风格也不像会使用这种手帕的人，而哈巴德夫人的手帕也在自己的包里。最后当天晚上看到的穿着猩红色睡衣的人到底是谁？没有任何一个人的睡衣是猩红色的，这些谜题困扰着波洛。</p>
<p>波洛在自己的行李箱中，发现了猩红色的睡衣，接受挑战的波洛开始了自己的推理。</p>
<h4 id="两个结论"><a href="#两个结论" class="headerlink" title="两个结论"></a>两个结论</h4><p>经过了侦讯之后，波洛最终想明白了整件事情。他给出了两个结论，让作为董事长的布克先生选择相信哪一个。</p>
<p>第一个结论，有一个卡塞蒂的仇人伪装成列车员偷偷混入了车厢中，用万能钥匙打开卡塞蒂的车厢，在晚上十二点三十七分将其杀害。由于动静过大而引来了列车员，无奈只好伪装成卡塞蒂以防止列车员强行进入，但是他不知道卡塞蒂根本不会法语。随后，他通过隔门，潜入隔壁的哈巴德夫人房中，将凶器顺手放入了哈巴德夫人的洗漱包中。无意间掉落了一颗纽扣。在出来之后，穿着猩红色睡衣伪装成女人，故意引起波洛的注意，混淆视听。最后将列车服和睡衣留在别人的行李之中，逃之夭夭。</p>
<p>在这个结论之中，在场的每一个人都是清白的，他们每个人也都有不在场证明，并且大家的证词中也相互印证了这一点。逻辑和证据上都没有丝毫的问题。但是，波洛给出了第二个结论。</p>
<p>第二个结论，卡塞蒂的死亡时间不是在十二点三十七分，而是在接近凌晨两点的时候，凶手先用药物让卡塞蒂昏迷，然后将怀表弄碎放入其口袋中，故意将烟斗通条留在现场。随后弄出声响以吵醒波洛，然后使用法语回复列车员米歇尔的敲门，并在此时哈巴德夫人也按铃以让米歇尔不至于在其门口呆过长时间。然后再安排一个女人穿着猩红色睡衣，以引起波洛的注意。是的，当死亡时间被推定到两点的时候，所有相互印证的不在场证明都将坍塌，而死者身上的十二处刀伤，也正是这节车厢上十二个人所自发组成的陪审团对卡塞蒂的审判。这节车厢上的每一个人，都与当年的阿姆斯特朗绑架案有关，麦克奎因是当时案件检察官的儿子，他非常喜欢阿姆斯特朗夫人；德贝纳姆小姐是阿姆斯特朗夫人的秘书；贝多斯是阿姆斯特朗上校军中的仆从；阿巴思诺特上校是阿姆斯特朗上校军中的朋友；德拉戈米罗夫公主是阿姆斯特朗夫人的教母；施密特小姐是阿姆斯特朗家的厨师并且是女仆波莱特的朋友；欧尔森小姐是黛西·阿姆斯特朗的保姆；斯卡雷里是阿姆斯特朗家的司机；哈德曼是当时调查案件的警察并爱上了女仆波莱特；米歇尔是波莱特的父亲；安德烈公爵夫人是阿姆斯特朗夫人的妹妹；哈巴德夫人是阿姆斯特朗夫人的母亲。</p>
<h4 id="正义还是公平"><a href="#正义还是公平" class="headerlink" title="正义还是公平"></a>正义还是公平</h4><p>在事件的结尾，布克先生选择了第一个结论，或许应该说阿加莎·克里斯蒂选择了第一个结论。相信每一个人看到这里，都会人为布克先生是个好人，车上的每一个人都是为了正义而处决了这个穷凶极恶的罪犯。而卡塞蒂的死，不过是罪有应得罢了。即使是阿加莎·克里斯蒂，在文章中也有大量的感情描写来凸显出这起案件的恶劣性质，并且通过小说人物之口来表明对罪犯的痛恶之情，实际上，阿姆斯特朗绑架案在现实中却有发生，这起案件是根据一九三二年小查尔斯·林德伯格绑架案改编而来。而当时案件被判死刑的德国移民布鲁诺·豪夫曼也同样被大家认为只不过是倒霉的替死鬼，这起真实的案件也由于其令人发指的犯罪过程，被视为“世纪犯罪”。</p>
<p>故事说到这里确实让人畅快淋漓，残忍的凶手最终得到了正法，大家带着正义的眼光去赞赏那十二个鼓起勇气为社会除去毒瘤的成员。同样，我并不为罪犯的死看到惋惜，但是，我也不会为这十二人得到赞扬而感到正义的光芒。反倒是为当时为了歌颂正义而牺牲公平感到遗憾。记得前几年，平民们都相当敌对为罪犯辩护的律师，认为罪犯就应该得到法律的严惩，为其罪犯辩解的人没有良知。这个世界上最可怕的暴力，就是剥脱人们为自己辩解的权利。法律存在的基础条件包含公平性，在每个人都平等的情况下我们才能去谈论正义。但是现在却越来越多人高举着正义的大旗，让社会的天平偏向自己。人性中最可怕的一点不是光明正大的犯罪，而是用正义的面孔去掩饰犯罪的本质。我们都在最求正义，但是在这条路上，我们很容易忘却，公平才是正义的源点。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;small&gt;&lt;em&gt;总字数：约38字，阅读时间：约7分钟&lt;/em&gt;&lt;/small&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;或许这本书的精华之处，不在于故事情节的环环相扣，不在于揭晓答案时的畅快淋漓，而在于结尾处，我们对公平和正义的思量。一个穷凶极恶的罪犯被杀了，凶手是否应该接受法律的裁决。或许，上个世纪大家都相信，正义才是关键，但是却没有人思考过，平等才是正义的源点。   —Kivi&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;这段时间特别迷恋侦探小说，在逛书评的时候无意间看到了这本《东方快车谋杀案》，被称之为“侦探小说之后”阿加莎·克里斯蒂的最杰出与最著名的作品。这本书的语言简单，相较于现代小说而言，没有过多的细节描写和感情分析，阅读起来十分轻松。当然，犯案手法也并没有太出人意料的地方，毕竟是上个时代的作品。但是，这本书最让我觉得惊艳的地方不在于它的情节或是描写，而在于他最后向我们传达的正义。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://arstead.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://arstead.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《百年孤独》 加西亚·马尔克斯 著</title>
    <link href="https://arstead.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Cien_a%C3%B1os_de_soledad/"/>
    <id>https://arstead.github.io/读书笔记/Cien_años_de_soledad/</id>
    <published>2017-04-10T13:50:55.000Z</published>
    <updated>2017-04-10T13:50:23.981Z</updated>
    
    <content type="html"><![CDATA[<p><small><em>总字数：约5000字，阅读时间：约10分钟</em></small></p>
<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>在一个月前就看完了这本书，但是却一直没有完成这篇读书笔记。本来想将所有的家族成员的记录一遍，但是发现这个故事太大，所以，我选取了我最喜欢的几个人物来分析。希望以后在回顾这本书时，能将这篇笔记完成。</p>
<p>看完这本书之后，真的不知道该怎么写这篇笔记，很想写好这篇笔记却又不知道如何下笔。很少看到如此宏壮而又细腻的小说了，叙述的手法如此精妙。乃至于我们已经放弃了纯粹的逻辑思考，沉浸其中。</p>
<blockquote>
<p>“因为年少的无知与浮躁，我差一点错过了它。所以当你还未尝过痛苦，当你还未开始尝试看透生命，请好好的收着它，不要读它。”      –<a href="https://www.douban.com/people/icekiller/" target="_blank" rel="external">豆瓣用户 阿落</a></p>
</blockquote>
<h4 id="喧闹的城镇"><a href="#喧闹的城镇" class="headerlink" title="喧闹的城镇"></a>喧闹的城镇</h4><blockquote>
<p>多年以后，面对行刑队，奥里雷亚诺.布恩迪亚上校将会回想起父亲带他去见识冰块的那个遥远的下午。那时的马孔多是一个二十户人家的村落，泥巴和芦苇盖成的屋子沿河岸排开，湍急的河水清澈见底，河床里卵石洁白光滑宛如史前巨蛋。世界新生伊始，许多事物还没有名字，提到的时候尚需用手指指点点。    –《百年孤独》 加西亚·马尔克斯</p>
</blockquote>
<p>嘲讽下而愤怒的何塞·阿尔卡蒂奥·布恩迪亚刺穿了普鲁邓西奥·阿基拉尔的喉咙。马孔多的故事拉开了序幕。害怕生出猪尾巴小孩的乌尔苏拉穿着贞洁裤一直不与何塞·阿尔卡蒂奥·布恩迪亚同房，其丈夫无能的谣言开始在村庄中传开。在斗鸡场上嘲弄他的普鲁邓西奥·阿基拉尔死在了他的长矛下。普鲁邓西奥·阿基拉尔的灵魂一直在他的家中留恋，最后，他们决定离开这个村庄。</p>
<a id="more"></a>
<p>马孔多这个名字不过是何塞·阿尔卡蒂奥·布恩迪亚梦中回荡的一个名字。他们和跟随他们一起离开的人一起在这里砍伐树木，建造村庄。何塞·阿尔卡蒂奥·布恩迪亚开始教大家如何耕种，畜牧，捕鸟，村庄有条不紊的发展着。吉卜赛人梅尔基亚德斯的出现给这个村庄带来了很多神奇的发明。但是只有何塞·阿尔卡蒂奥·布恩迪亚痴迷于这些新奇的物件。磁铁，望远镜，放大镜等等让他着迷，在梅尔基亚德斯的帮助下，他建造了一间炼金实验室，并沉迷于其中。</p>
<p>如果说马孔多应该是由何塞·阿尔卡蒂奥·布恩迪亚建造起来的，那他们的家就是由乌尔苏拉一手打造的。家中的一切事务都是有乌尔苏拉打理。乌尔苏拉生了两个男孩和一个女孩，何塞·阿尔卡蒂奥，奥雷里亚诺·布恩迪亚和阿玛兰妲。这些小孩并没有想她所恐惧的那样长着猪尾巴。乌尔苏拉通过在售卖糖果来维持家中的生活。</p>
<p>城镇的喧闹点缀出一片繁华的景象，除了沉静在炼金实验室的何塞·阿尔卡蒂奥·布恩迪亚，似乎没有任何的现象表明，这个家族蕴含着被孤寂笼罩的命运。</p>
<h5 id="何塞·阿尔卡蒂奥·布恩迪亚"><a href="#何塞·阿尔卡蒂奥·布恩迪亚" class="headerlink" title="何塞·阿尔卡蒂奥·布恩迪亚"></a>何塞·阿尔卡蒂奥·布恩迪亚</h5><p>马孔多的建造者，一个沉迷于炼金的男人。带领众人离开原有的村落，他内心包含着对新鲜事物的好奇心。每次吉卜赛人的出现都能扣动他的心弦，与梅尔基亚德斯的深交也让他感受到了科技的魅力。在完成了村落的建造之后，就开始沉浸在炼金之后，似乎心中已经没有其他的事物。梅尔基亚德斯似乎依然成为何塞·阿尔卡蒂奥·布恩迪亚的精神支柱。乌尔苏拉为梅尔基亚德斯在炼金作坊旁边新盖了一间房间，不再离开村庄的梅尔基亚德斯从此不再离开那间房间，会去的地方仅仅只有旁边的炼金作坊。梅尔基亚德斯不断的在羊皮纸上涂写这迷一样的文字，没有人能解读，但却一直被人保留着，直至最后一代人，解读出其中蕴含着命运的记录，为这个家族画上最后的句号。</p>
<p>梅尔基亚德斯死后，何塞·阿尔卡蒂奥·布恩迪亚难以接受这样的事实，其认为梅尔基亚德斯已经达到了永生而拒绝为其下葬。他用复活配方希望能将其复活，但是无济于事。腐烂的尸体让家中充满恶臭，最后他不得不为这一身的挚友举行了一场隆重的葬礼，这是马孔多第一场也是人数最多的一场葬礼。梅尔基亚德斯死后，何塞·阿尔卡蒂奥·布恩迪亚又回到了自己作坊，继续他的工作。他不再吃饭，不再睡觉，将自己带入了一种永恒的谵妄状态，他开始自言自语，开始歇斯底里。终于，孤寂的疯狂将他推向了精神的深渊。他砸烂了他所有的炼金设备，毁坏家中的各种家具。最后，二十多人合力才将他捆绑在树上。而他在这棵书下，一呆就呆到了死亡。</p>
<p>何塞·阿尔卡蒂奥·布恩迪亚是一位天才，是这个村庄中唯一一位能与梅尔基亚德斯交流的人。但是，他却无人能理解。没有人相信他发现“我们所处的世界是圆的”的理论。唯有梅尔基亚德斯能与他产生共鸣。他唯一的挚友去世后，他已经失去了对这个世界的眷恋，将自己封闭起来，默默感受自己的孤独。</p>
<h5 id="奥雷里亚诺·布恩迪亚"><a href="#奥雷里亚诺·布恩迪亚" class="headerlink" title="奥雷里亚诺·布恩迪亚"></a>奥雷里亚诺·布恩迪亚</h5><p>上校或许是马孔多最不幸的人吧。奥雷里亚诺·布恩迪亚从小就继承了何塞·阿尔卡蒂奥·布恩迪亚的炼金受益，他能和父亲一样在炼金作坊安安静静的呆着。他似乎从小就受到其父亲的爱戴。在他跟随父亲拜访里正堂阿波利纳尔·摩斯科特时，第一次遇见了年龄上能当其女儿的雷梅黛丝·摩斯科特。那是一种肉体上的感觉，几乎在他行进时构成了障碍，就像鞋子里进了一粒小石子。无法抵御内心躁动的奥雷里亚诺·布恩迪亚开始在庇拉尔·特尔内拉身上需要欲望的解脱，但这种肉欲的满足无法填充他的内心。他最终将雷梅黛丝·摩斯科特娶回家中，从人情世故开始，教会她慢慢成长。而这个家庭也在雷梅黛丝·摩斯科特照料下变得热闹起来。</p>
<p>雷梅黛丝·摩斯科特在夜晚中的暴死似乎让这个家庭又回归了寂静。奥雷里亚诺·布恩迪亚想平常经常去其岳父家玩多米诺骨牌。与里正的接触让他接触到了政治，在周围环境的影响下，他不断的被拉入这场政治的深渊。自由派和保守派的战争，让他彻底卷入其中。终于，他加入了自由派。</p>
<p>奥雷里亚诺·布恩迪亚上校发动了三十二场武装起义，无一成功。他在战时与十七个女人有过接触，生下了十七个儿子，但是在战后全部被暗杀。他逃过了十四次暗杀，七十三次伏击和一次枪决。他是一个让政府军闻之丧胆的人物，但是战争的喧嚣让他向往宁静。他签订了最终的尼兰迪亚协定，正式退出战争。他放弃了总统给他颁发的勋章，放弃了战后的退休金。躲进了炼金小作坊，靠制作小金鱼维持生计。</p>
<p>没有人知道，他为了这场战争牺牲了多少，没有人知道，他在尼兰迪亚协定上签字时的心情。他为了胜利而战斗过，同样为了失败而战斗过。“死亡远比想象的要难”，这种信念撑起了他的躯体。在战争的最后，他赢得了一场比胜利更艰难、更血腥、代价更高昂的失败。</p>
<p>他经历了很多，在牢狱中煎熬过，在行刑中的死里逃生，远离他乡多年。他胜利过也失败过。但最后，他还是回来了。似乎是布恩迪亚家族血统带来的牵挂。他放弃了一切的斗争，当二十一位曾经的队友来央求他继续发动起义时，他放弃了。当人们认为他是贪生怕死而唾弃他时，他没有任何言语，他承受的太多太多。我看到他在尼兰迪亚协定后拿枪对着自己时的释怀，这一枪让彻底回归一个正常人的生活。终于，回到了他的炼金作坊。一遍又一遍的制作小金鱼，独自享受着难得的孤独。</p>
<h5 id="何塞·阿尔卡蒂奥"><a href="#何塞·阿尔卡蒂奥" class="headerlink" title="何塞·阿尔卡蒂奥"></a>何塞·阿尔卡蒂奥</h5><p>何塞·阿尔卡蒂奥似乎从一出生就只存在于自己的世界中。在家中的他不参与父亲的炼金。独自一人慢慢成长，变成了体格魁梧的人。发育完好的何塞·阿尔卡蒂奥吸引着庇拉尔·特尔内拉，无法抵挡诱惑的何塞·阿尔卡蒂奥将自己交给了庇拉尔·特尔内拉。庇拉尔·特尔内拉怀孕了，这个消息打破了何塞·阿尔卡蒂奥的生活。或许因为逃避，或许因为不知所措，何塞·阿尔卡蒂奥混迹于集市之中。在集市上，他被一个吉卜赛女郎吸引，两个人在喧闹的集市里释放自己的欲望。最后，何塞·阿尔卡蒂奥跟随着吉卜赛女郎一起离开了马孔多。</p>
<p>在为雷梅黛丝·摩斯科特服丧时，何塞·阿尔卡蒂奥回来了。开门的那个瞬间，房柱颤动不已，他粗壮的胸背几乎无法挤进门来，浑身的刺青似乎见证了他在外的流浪。回来后的他并不能融入这个家庭，白天吃过早饭遍去村里的妓院，晚上回来又继续睡觉。但是，丽贝卡却被他阳刚之身吸引，在寂寞难耐的深夜，闯入他的房间。丽贝卡沉浸在由无法承受的痛苦生出的不可思议的快感之中。他们结婚了。</p>
<p>无法接受兄妹相爱的乌尔苏拉将他们永远逐出了家门，他们在公墓对面租了一间小屋，继续他们无人打搅的生活。在公墓被枪决的阿尔卡蒂奥，见到最后一面的人，也只有何塞·阿尔卡蒂奥和丽贝卡。</p>
<p>奥雷里亚诺·布恩迪亚上校被逮捕并将要行刑的那天清晨，何塞·阿尔卡蒂奥带着自己的猎枪，解救了他，没有任何的表情，没有任何的交流。奥雷里亚诺·布恩迪亚上校又开始他新一轮的战争。而何塞·阿尔卡蒂奥继续过着他白天打猎，晚上睡觉的平稳日子。直至一个平常的夜晚，何塞·阿尔卡蒂奥回到卧室后响起的一声枪声。没有人知道凶手是谁，何塞·阿尔卡蒂奥躺在血泊中，弥漫在硝烟之中。而丽贝卡从此关上家门，过上了活死人的生活。</p>
<h5 id="阿玛兰妲"><a href="#阿玛兰妲" class="headerlink" title="阿玛兰妲"></a>阿玛兰妲</h5><p>阿玛兰妲的故事从与丽贝卡的爱情斗争中开始时，被收养的丽贝卡和阿玛兰妲基本上算是一起长大。她们同时被意大利技师皮埃特罗·克雷斯皮所吸引。然而在梅尔基亚德斯逝世后，阿玛兰妲向皮埃特罗·克雷斯皮表达爱意时，才知道其已经跟丽贝卡定下婚约。愤怒的阿玛兰妲立下誓言阻止姐姐丽贝卡的婚礼。在同一时期举办丽贝卡和雷梅黛丝的婚礼前夕，皮埃特罗·克雷斯皮收到一封匿名信被告知其母亲病危，其马不停蹄赶回家中，他错过了路上遇母亲的相遇。等他返回婚礼时，却只能打扫婚礼的残烛余烬。阿玛兰妲劝说乌尔苏拉将他们的婚礼安排在三年后教堂建成之时，她取走放在丽贝卡婚纱中的樟脑丸，导致所有的服饰都被蛾子蛀成粉末。她向上帝祈祷发生某种可怕的事情免得自己要向丽贝卡下毒来延迟婚礼，雷梅黛丝的死将他们的婚礼无限期的延后了。</p>
<p>在丽贝卡与何塞·阿尔卡蒂奥结婚之后，乌尔苏拉感觉到了无比的愧疚，依旧每周邀请皮埃特罗·克雷斯皮来家中吃饭，而阿玛兰妲与她的感情似乎也越来越亲昵。但是，无法接受自己的阿玛兰妲拒绝了他的求婚。最后，奔溃的皮埃特罗·克雷斯皮自杀了。而她，将自己的手烧伤之后，带上了黑纱，致死都没有摘下。</p>
<p>阿玛兰妲一生都没有结婚，他拒绝了赫里内勒多·马尔克斯上校的求婚。唯一让她内心炽热的，只有奥雷里亚诺·布恩迪亚和庇拉尔·拉尔内拉的儿子，他的侄子奥雷里亚诺·何塞。阿玛兰妲从奥雷里亚诺·何塞小的时候就一直照顾着他，她已经习惯了当着他的面脱下衣服。他们相互吸引，却又相互藏匿自己的感情。当阿玛兰妲从狂热中惊醒后，断然拒绝了这段不论的关系。奥雷里亚诺·何塞也搬到军营里去生活，并最终跟随军队一起离开。从军队回来的奥雷里亚诺·何塞一心想跟阿玛兰妲结婚，阿玛兰妲依旧拒绝了他。</p>
<p>阿玛兰妲封闭了自我，她的内心始终蕴含嫉妒，她希望自己过的比丽贝卡好，活的比丽贝卡长。死神的眷顾让她能够调整自己的死亡时间。她一针一针的为自己缝制寿衣，一缝就是四年，如同当年上校制作小金鱼一般。或许，内心的禁闭才是世界上最深邃的孤独。最后的她为了救赎，为了弥补自己卑微的一生，她帮镇子里的人给逝者带信。她永久的躺进了自己的棺椁之中。这已然成为他一生的解放。她一生没有跟任何男性接触，始终守节。这是对自己的惩戒，为了前半生的错误而选择将自己的后半生奉献给了孤独。这，才是她希望得到的归宿。</p>
<h4 id="孤独何止百年"><a href="#孤独何止百年" class="headerlink" title="孤独何止百年"></a>孤独何止百年</h4><p>刚开始阅读这本书时，脑海中充满了疑惑，百年孤独由何而来？整本书中的每一个故事都表现出一派繁华热闹的景象。马孔多热闹非凡的市区，人口众多的布恩迪亚一家。但是，喧嚣的外表下隐藏的是禁锢着内心的囚笼。百年之后，布恩迪亚一家都没能摆脱命运的束缚。正如文中所言，阿尔卡蒂奥生来强壮，总是在鲁莽中结束自己的生命，无法承受孤独的人都受到了死神的青睐，奥雷里亚诺生来孤寂，辉煌的一生中总是伴随着孤寂，他们都很享受，他们沉浸在自己的世界之中，似乎这才是他们最好的归宿。</p>
<p>回过头来看，命运的齿轮被何塞·阿尔卡蒂奥·布恩迪亚的一根长矛撬动，梅尔基亚德斯早已为他们谱写好了家族的轮回。这个家庭成员中的每一件事都蕴含在羊皮卷中，这些羊皮卷也在等待着，它们在阁楼中静候百年，等待这真正能够享受自我世界的人来解除命运的安排。这也许就是一个家庭的救赎，如果，何塞·阿尔卡蒂奥·布恩迪亚不是一个鲁莽的人呢？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;small&gt;&lt;em&gt;总字数：约5000字，阅读时间：约10分钟&lt;/em&gt;&lt;/small&gt;&lt;/p&gt;
&lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;在一个月前就看完了这本书，但是却一直没有完成这篇读书笔记。本来想将所有的家族成员的记录一遍，但是发现这个故事太大，所以，我选取了我最喜欢的几个人物来分析。希望以后在回顾这本书时，能将这篇笔记完成。&lt;/p&gt;
&lt;p&gt;看完这本书之后，真的不知道该怎么写这篇笔记，很想写好这篇笔记却又不知道如何下笔。很少看到如此宏壮而又细腻的小说了，叙述的手法如此精妙。乃至于我们已经放弃了纯粹的逻辑思考，沉浸其中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“因为年少的无知与浮躁，我差一点错过了它。所以当你还未尝过痛苦，当你还未开始尝试看透生命，请好好的收着它，不要读它。”      –&lt;a href=&quot;https://www.douban.com/people/icekiller/&quot;&gt;豆瓣用户 阿落&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;喧闹的城镇&quot;&gt;&lt;a href=&quot;#喧闹的城镇&quot; class=&quot;headerlink&quot; title=&quot;喧闹的城镇&quot;&gt;&lt;/a&gt;喧闹的城镇&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;多年以后，面对行刑队，奥里雷亚诺.布恩迪亚上校将会回想起父亲带他去见识冰块的那个遥远的下午。那时的马孔多是一个二十户人家的村落，泥巴和芦苇盖成的屋子沿河岸排开，湍急的河水清澈见底，河床里卵石洁白光滑宛如史前巨蛋。世界新生伊始，许多事物还没有名字，提到的时候尚需用手指指点点。    –《百年孤独》 加西亚·马尔克斯&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;嘲讽下而愤怒的何塞·阿尔卡蒂奥·布恩迪亚刺穿了普鲁邓西奥·阿基拉尔的喉咙。马孔多的故事拉开了序幕。害怕生出猪尾巴小孩的乌尔苏拉穿着贞洁裤一直不与何塞·阿尔卡蒂奥·布恩迪亚同房，其丈夫无能的谣言开始在村庄中传开。在斗鸡场上嘲弄他的普鲁邓西奥·阿基拉尔死在了他的长矛下。普鲁邓西奥·阿基拉尔的灵魂一直在他的家中留恋，最后，他们决定离开这个村庄。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://arstead.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://arstead.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《窗边的小豆豆》 黑柳彻子 著</title>
    <link href="https://arstead.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%AA%93%E3%81%8E%E3%82%8F%E3%81%AE%E3%83%88%E3%83%83%E3%83%88%E3%81%A1%E3%82%83%E3%82%93/"/>
    <id>https://arstead.github.io/读书笔记/窓ぎわのトットちゃん/</id>
    <published>2017-04-06T08:30:55.000Z</published>
    <updated>2017-04-06T15:06:15.977Z</updated>
    
    <content type="html"><![CDATA[<p><small><em>总字数：约2300字，阅读时间：约6分钟</em></small></p>
<blockquote>
<p>无论哪个孩子，当他出世的时候，都具有优良的品质。在他的成长过程中，会受到很多的影响，有来自周围环境的影响，也有来自成年人的影响，这些优良品质可能会受到损害。所以我们要早早地发现这些“优良的品质”，并让它们发扬光大，把孩子们培养成富有个性的人。   —小林宗作</p>
</blockquote>
<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>记得第一次看这本书是在初中的时候。当时的我很懵懂，自己也只是一个什么都不懂的小孩。在我眼中的巴学园仅仅是一个让人羡慕的学校，没有固定的位置，可以上自己喜欢的课，每天都有玩乐的时间。现在，经历了沧海桑田之后，回过头来，再看这本书，却看到了一片不一样的风景。我看到的小孩子们的天真，看到为了保持孩子们天性的校长先生。在这本书里，我看到了一个完整的孩子们的世界。</p>
<a id="more"></a>
<h4 id="只是换了个地方读书"><a href="#只是换了个地方读书" class="headerlink" title="只是换了个地方读书"></a>只是换了个地方读书</h4><p>或许，这本书中最让我钦佩的，不是小林先生，而是小豆豆的母亲。被退学，无论在怎么样的社会中，都被认为是一件可耻的事情。往往，在成年人的世界中，这代表不够优秀，甚至是有缺陷。父母的怨气会开始扩散到孩子们的心中，让孩子们从小就产生了自己不如别人的心理暗示。这对孩子们的成长无疑是巨大的打击。而小豆豆的母亲并没有将这件事告诉小豆豆，她虽然为小豆豆感到忧心，但是她并没有责怪她，只是跟她说换了一个地方读书。幼小的心灵的到呵护，才有可能健康的成长。</p>
<h4 id="他是唯一一个能听我说四个小时话的人"><a href="#他是唯一一个能听我说四个小时话的人" class="headerlink" title="他是唯一一个能听我说四个小时话的人"></a>他是唯一一个能听我说四个小时话的人</h4><p>校长先生最让我敬佩的是，他完全抛开了大人对小孩固有的偏见。将自己完全转换为一个大小孩的角色与小孩沟通。这一点对于一个成年人都是无比困难的。从跟小孩们交流时保持蹲下的姿势，以保证跟孩子们的高度相同，到小豆豆为了捞掉进厕所的钱包而舀便池时的那一句记得放回原处。每一个细节都表现出他不是在一个大人的视角在看待这些人，而是跟小孩一样平齐平做。想象看，当小孩在做一件很奇怪或者很困难的事情时，有多少父母会让孩子继续进行下去，而又有多少父母会帮着孩子解决问题。但是，如果当朋友在做这样的事情时，我相信，没有多少人会加以阻止或者强行给予帮助。想想吧，我们在跟孩子沟通的时候，已经不自觉的将自己转换成了一个大人的身份。这种固有的偏见已经无法让我们感受到孩子的声音，我们只跟随自己的想法走，小孩的天性就这样被我们错过了。</p>
<h4 id="山的味道，海的味道"><a href="#山的味道，海的味道" class="headerlink" title="山的味道，海的味道"></a>山的味道，海的味道</h4><p>“大家都把山的味道，海的味道带来了么？”巴学园的午餐时间总是这么的有趣，山的味道，海的味道不仅仅能让大家学到各种食材的来源，更让大家摆脱了午餐的攀比。每个人吃的都是山的味道和海的味道，而不是山珍海味和粗茶淡饭，即使有同学没有凑齐这两种菜，校长先生也会自己为他们补上不足的部分。每个人的都是一样的，没有比较，大家都沉浸在这种味道中。</p>
<h4 id="大家一起光着游泳吧"><a href="#大家一起光着游泳吧" class="headerlink" title="大家一起光着游泳吧"></a>大家一起光着游泳吧</h4><p>初中读这本书的时候，相当不理解这样的行为。即使是小学生，也应该已经有了羞耻心，知道男女的身体构造不相同，要我肯定是不会同意这样的事情发生。但是，现在回过头来看，却发现这个办法真是太好了。处在儿童时期的我们，把自己带入场景后，肯定会有所排斥，这也是我们作为孩童时会出现的缺点。这个时候，环境的影响就变得颇为重要。很多事情，一个人做是诡异，一群人做就是流行。当大家都认同了这样的环境之后，内心的想法也会随着环境而波动。在巴学园的泳池中，大家都是一样的，没有任何人是异类，每一个人都是相同的，这也是环境带来的影响。从小就种下了平等的种子。</p>
<h4 id="我保证下一次不跳报纸和沙坑了"><a href="#我保证下一次不跳报纸和沙坑了" class="headerlink" title="我保证下一次不跳报纸和沙坑了"></a>我保证下一次不跳报纸和沙坑了</h4><p>看到小豆豆如此纯真的思考方式，似乎把自己也带回到了小时候。小时候，我们一步一步成长，第一次跌倒时我们认为这个地方很危险，而后的跌倒开始让我们知道危险的不是这个地方，而是我们跑的太快。小豆豆也是这样，跳报纸的时候不慎跌入井盖中，跳沙坑发现里面是水泥，单纯的孩子认为只有报纸和沙坑才是危险的原因。我们一步一步长大了，思维也一点一点成熟了。我们知道受到伤害的根源是什么，我们用我们固有的思维来看这个世界。听到一句谎言就认为这个世界都是欺骗，受过一次伤害就认为世间没有好人，殊不知我们早已忘却了最原始的思考方式。</p>
<h4 id="怎么样才能不让别人发现这枚硬币"><a href="#怎么样才能不让别人发现这枚硬币" class="headerlink" title="怎么样才能不让别人发现这枚硬币"></a>怎么样才能不让别人发现这枚硬币</h4><p>在公交车上用脚踩住地面上别人遗失的硬币之后，小豆豆的思绪是紧张的。我该怎么捡起这枚硬币才能让别人觉得我不是想独占这枚硬币，交给别人的话别人会不会留为己用，带回家给妈妈的话，妈妈会不会觉得我是捡到钱不交给警察的坏孩子，回到家之后的异常举动。这些孩子们的纯真，在大人看来或许幼稚，或许可笑，但是这才是孩子应该有的天性。</p>
<h4 id="下一次，我们办一个什么样的学校呢"><a href="#下一次，我们办一个什么样的学校呢" class="headerlink" title="下一次，我们办一个什么样的学校呢"></a>下一次，我们办一个什么样的学校呢</h4><p>战争的炮弹摧毁的只有学校的建筑，摧毁不了学校的灵魂。巴学园的种子已经在每一个从这里走出去的人心中发芽，成长。孩童是坚持的信念，是这一生品行的支柱。在这个有几辆电车组成的学校里，我看到了每一个人都是平起平坐，我看到孩子们自由生长空间，我看到欢声笑语中隐含着幼稚和单纯。下一次，我们有要怎么样来陪伴小孩的成长呢？</p>
<h4 id="童真的语言"><a href="#童真的语言" class="headerlink" title="童真的语言"></a>童真的语言</h4><p>“我想，也许星星是白天睡觉，晚上起床，亮闪闪的发光吧？”“大家都把山的味道和海的味道带来了吗？”“哎-，我本来是个间谍，但装作售票员的样子，怎么样？”“无论什么样的身体，都是美丽的。”“从盒子里就能看到相扑，是怎么回事呢？相扑力士们那么大，怎么能来到我家，还钻进盒子里去呢？”</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;small&gt;&lt;em&gt;总字数：约2300字，阅读时间：约6分钟&lt;/em&gt;&lt;/small&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;无论哪个孩子，当他出世的时候，都具有优良的品质。在他的成长过程中，会受到很多的影响，有来自周围环境的影响，也有来自成年人的影响，这些优良品质可能会受到损害。所以我们要早早地发现这些“优良的品质”，并让它们发扬光大，把孩子们培养成富有个性的人。   —小林宗作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;记得第一次看这本书是在初中的时候。当时的我很懵懂，自己也只是一个什么都不懂的小孩。在我眼中的巴学园仅仅是一个让人羡慕的学校，没有固定的位置，可以上自己喜欢的课，每天都有玩乐的时间。现在，经历了沧海桑田之后，回过头来，再看这本书，却看到了一片不一样的风景。我看到的小孩子们的天真，看到为了保持孩子们天性的校长先生。在这本书里，我看到了一个完整的孩子们的世界。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://arstead.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://arstead.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《嫌疑人X的献身》 东野圭吾 著</title>
    <link href="https://arstead.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/The_Devotion_of_Suspect_X/"/>
    <id>https://arstead.github.io/读书笔记/The_Devotion_of_Suspect_X/</id>
    <published>2017-03-28T03:18:55.000Z</published>
    <updated>2017-03-28T15:10:57.149Z</updated>
    
    <content type="html"><![CDATA[<p><small><em>总字数：约4000字，阅读时间：约10分钟</em></small></p>
<blockquote>
<p>自己想出解答，和判断别人说的解答是否正确，何者比较简单-这是个著名的难题。 —东野圭吾</p>
</blockquote>
<p>这是一本推理小说。见证的却是一场壮烈的爱情故事，更准确的是，是一个人的爱情故事。</p>
<h4 id="故事简述"><a href="#故事简述" class="headerlink" title="故事简述"></a>故事简述</h4><p>故事起源于一场误杀事件。花岗靖子和花冈美里母女俩为了躲避前夫富坚慎二，而换了新的工作，并且搬离的原来的住处。但是，富坚还是找到了他们。面对的富坚的咄咄逼人，母女俩冲动之下将富坚杀害。一筹莫展之际，她们的邻居，数学奇才石神出面帮忙处理善后。故事从这里开始了。</p>
<a id="more"></a>
<p>刑警草薙是这个案件的主要负责人，在一个荒野中，发现了一具脸和指纹都被砸烂的尸体，周围有未被烧完的衣物和一辆崭新的自行车。而富坚慎二所居住的宾馆，由于客人没有退房，而通知了警方。被证实衣服属于富坚而且自行车上的指纹也与富坚居住房间中的指纹相同。花岗靖子作为主要的嫌疑犯，一直在被调查，而石神作为她们的邻居，也接受了调查。但是，在警方判定的死亡时间三月十日晚上这段时间，靖子和美里都有完美的不在场证明，当天晚上电影票的票根及卡拉OK店员的证词都是她们没有时间行凶的有力有利证词。而且也找不到任何证据表明靖子是真凶。</p>
<p>汤川学是草薙的挚友，两个人同为帝国理工大学的学生。作为文科生的草薙遇到了无法解释的问题时，总喜欢跟作为物理学教授的汤川交流。而作为帝国理工大学理工科院系出了名的数学奇才，拥有达摩封号的石神跟汤川早已相识。处于对故友的情怀，汤川加入了这场游戏。</p>
<p>所有的事情都在石神的掌控之中，警方开始调查自行车，而车主在三月十日被窃后，立即报案，并记录了失窃位置，在距离尸体发现一个站远的条崎车站，这两个位置都距离靖子家有一段距离。警方希望能找到跟死者有任何关系的资料，但是却丝毫没有进展。就在警方已经失去对花岗靖子的兴趣之后，汤川学的介入让案件的逻辑漏洞一点一点的浮现。</p>
<p>为什么凶手有时间将脸和指纹处理掉，却没有时间等衣服烧毁完并且处理掉自行车上的指纹再离开现场。为什么在条崎车站那么多车甚至还有没上锁的旧车，死者要选择一辆崭新的车，这辆车极有可能上锁，死者还得准备能处理铁锁的钳子。为什么死者会死在荒野，如果是抛尸，花岗母女不可能有时间完成这样的事情，而且需要开车才能将尸体运来，那么一定存在帮凶。但是，唯一可能的帮凶并没有车，在这段时间也没有任何的租车记录。一连串的问题困扰着汤川，而草薙却对此并没有任何兴趣。</p>
<p>石神家的附近有一条河，作为中学老师的石神上班路上都要经过这条河。河边有一排蓝色胶布覆盖的住处，都是一些无业游民居住的地方。石神每天都会看到他们，周而复始，这群人没有亲人，没有朋友，或许，连知道他们名字的人都没有。过了桥，石神每天都会到马路对面靖子工作的天亭快餐店去买便当，看上去是买便当，实际上他是为了去看靖子，是的，石神喜欢靖子。在那个准备自杀的下午，靖子的突然到访拯救了石神，从那时起其，石神就一直默默的爱恋着她。</p>
<p>虽然不善言辞的石神没怎么跟靖子说过话，但是天亭的其他工作人员都将这件事作为八卦流传着。富坚死后，为了表明他们之间并没有过多的联系，石神便很少去那家便利店了。他们之间都是通过石神每天晚上去公共电话亭打电话给靖子来进行交流，靖子一天中发生的所有事都会告诉石神。</p>
<p>工藤邦明此时的出现为这场命案添加了更多色彩。工藤是靖子早年做陪酒工作时的常客，他看到富坚死后的新闻立刻赶来安慰靖子。实际上，工藤一直都喜欢着靖子，而靖子也喜欢着身为企业家的工藤。但是，她感受到了来自石神的爱恋，石神的付出让她受到了另一种压迫，比富坚慎二带来的压迫更为强烈。她没有将这件事告诉石神。而石神见过工藤送靖子回来时，靖子看工藤的眼神，他渴望得到这种眼神。</p>
<p>汤川引导着故友石神来到便利店，一向不拘一格的数学家石神却在到便利店之前微微的整理了自己的衣服。这一个微小的细节被汤川看在眼里，只有他看出来，石神对靖子的爱恋。在便利店中，工藤的出现让气氛变得异常紧张。同样思维敏捷的汤川就在旁边，此时的对话稍有不慎就可能暴露一切。但是，每一个细节汤川都看在眼里，他知道，这件案子一定跟石神有关。</p>
<p>如果只是刑警的话，或许这件案子永远找不出凶手是谁。汤川的调查逐步揭开了这场凶案的面纱。但是，连汤川自己都觉得，隐藏在这件事背后的真相令人胆战心惊。汤川和石神漫步在石神家附近的河边，他们看着那群无业游民。</p>
<blockquote>
<p>“看着那些游民，就觉得他们的过日子像时钟一样准确。你我都不可能摆脱时钟的束缚，彼此都已沦为社会这个时钟的齿轮，一旦少了齿轮，时钟就会出乱子。纵然自己渴望率性而为，周遭也不容许我们这样做。这虽然同是也让我们得到了安稳，但失去自由也是不争的事实。在游民当中，似乎也有不少人不想回到原本的生活。这世上没有无用的齿轮，也只有齿轮本身能决定自己的用途。”—汤川学</p>
</blockquote>
<p>汤川学的这段话让石神知道，现在只有最后一张牌可以打了。</p>
<p>石神去自首了，带着他心爱的数学资料。他描述了整个犯罪经过，在他的描述中，警察认为这是一个有癔症的追踪变态狂。他认为自己是靖子的保镖；他在自己家中装上了窃听器，然后认为靖子在家中的抱怨都是对自己说的，并且了解到富坚慎二在骚扰着她们母女；他每天都用公共电话打电话给靖子，他给工藤发了恐吓信让他离开靖子；他通过诱骗的方式将前来找靖子的富坚引到荒野，然后在条崎偷了一辆自行车去那将富坚杀害；行凶时用的绳子就在他家。石神事先也给靖子安排好了要如何回应警察的询问，只是，他没有告诉靖子他要去自首。</p>
<p>一切的一切在任何一个人看来相当合理。合理的杀人动机，被找出的各种证物以及逻辑完整的杀人流程。这是对汤川学的最后一击。石神知道，现在已经没有任何证据能表明自己不是凶手，就算汤川学再怎么想阻止这件事，也无力回天了。</p>
<p>石神算中了案件的每一个环节，每一个逻辑都完美无缺。但是，智商超群的他唯独看不透的就是人心。</p>
<p>调查出真相的汤川学不愿看到自己的故友就此白白牺牲，决定将这个选择的权利交给靖子。汤川学将所有的真相告诉了靖子，石神从第一天开始，就已经切断了自己的后路。因为，他真的杀了人。三月九日是富坚慎二的死亡时间，当天晚上石神和靖子母女擦掉了所有富坚的痕迹，并将凶器留在了自己家中。为了彻底洗脱靖子的嫌疑，石神将富坚住的宾馆里所有富坚的痕迹都擦除了，然后他在无业游民中雇佣了一个人假冒富坚慎二，让他回到富坚的公寓。并且偷了一辆崭新的车，然后在晚上到约定的荒野中去。石神用带去的凶器将其杀害，并伪造了现场。而富坚的尸体，早已被他肢解并一块块的抛弃到河中。所以，至始至终刑警都在围绕三月十日展开调查，调查的尸体也只是一个无业游民的尸体。刑警的调查从来没有切入过真正的案情。</p>
<p>知道真相的靖子，自首了。她无法在这样的情况下继续无所顾虑的活下去。在监狱中遇见靖子的石神发出野兽般的咆哮，夹杂着绝望与混乱的哀嚎。</p>
<h4 id="一场所有人的献身"><a href="#一场所有人的献身" class="headerlink" title="一场所有人的献身"></a>一场所有人的献身</h4><p>环环相扣的逻辑中，透露出来的不仅仅只是警匪之间的博弈，更是每一个人的内心。看似石神的舍身奉献，实为所有人的决择。</p>
<p>东野圭吾的小说总是让人满含惊喜。相较于其他推理小说总是有条不紊推进犯罪剧情而言，这本小说一上来就告诉你真凶是谁。在游戏刚刚开始就走进高潮，这似乎有悖于传统推理小说的阅读思路。我们总是希望能自己找出真凶是谁，阅读的乐趣似乎已经变成了对结果的期待。<strong>我们忘却了推理，过程才是最核心的，结果只不过是过程的一个推论。</strong>这本小说将犯案的过程完美的诠释出来。让读者们集中注意于推理的核心部分，一步一步被引入案件之中，令人深陷其中。</p>
<p>故事的主角无疑是智商过人的石神，但是，他却不是以一个正义的形象出现的。帮杀人犯隐瞒案情，自己也成为了一个手上沾满鲜血的人。他爱靖子，这是一种轰轰烈烈的爱。或许在自杀是遇见靖子的那一刻，他就知道自己终身都将保护这个女人。石神的内心是扭曲的，在他的世界中，只有完整的逻辑链，似乎连爱情也被计算到他的逻辑之中。他算尽一切，唯独没有想到的是，他爱的人只是一个普通人，根本无法接受这种奉献带来的压力。即使苟活于世，也将如行尸走肉一般。石神在这场游戏中输了，输的很彻底。</p>
<p>花岗靖子是一切故事的起源，如果没有石神，或许靖子会选择直接自首。但是在石神的帮助下，她的嫌疑一点一点被排除。她开始私下里跟工藤接触，她心里知道石神对她的爱意，但是她对石神有的只是感激，她喜欢上了工藤。她希望能像一个正常人一样过上平凡没有压迫的生活。但是石神的付出带给她的不仅仅是幸免于牢狱之灾，还有的是比富坚慎二更加强烈的压迫感，这种压迫感不是出于别人的恶，而是出于别人的善。现实往往如此，过分的善意带来的只有压力。知道真相后的靖子终于被击垮了，她无法承接这样的善，她无法让自己就这样看着石神步入深渊，她选择会放弃，放弃承受这一切的善。最后的每一声“对不起”都直击我们的心灵。这是她最后的献身。</p>
<p>汤川学或许才是这个故事中的侦探。作为罪人的故友，他一点一点解开案件的帷幕，但是却发现，自己也一步一步被推入真相的深渊，真相是如此的让人胆颤心惊。作为故友，他不忍让石神就这样平白无故的牺牲，甚至连元凶都不知道是怎么回事。但是，他知道，当真相被揭露，才是对故友最沉重的伤害。<strong>哪怕侦探知道了一切，他也必须做出抉择，不说出真相，眼前一切如故；但说出真相，他将亲手毁掉一切，甚至包括他自己，侦探本人将同样成为罪人。</strong>他做出了自己的选择，他选择了真相，即使自己将会沦落成为罪人，这是一个侦探的献身。</p>
<p>这是一场彻头彻尾的悲剧。富坚慎二的死亡，花岗母女的毁灭，石神的献身，汤川学的决择以及那一位无辜的流浪汉。结局的嘶吼让我们感受到了无尽的悲凉。两份爱情的破裂，两位难逢敌手的挚友，一场精心策划的谎言。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;small&gt;&lt;em&gt;总字数：约4000字，阅读时间：约10分钟&lt;/em&gt;&lt;/small&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;自己想出解答，和判断别人说的解答是否正确，何者比较简单-这是个著名的难题。 —东野圭吾&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是一本推理小说。见证的却是一场壮烈的爱情故事，更准确的是，是一个人的爱情故事。&lt;/p&gt;
&lt;h4 id=&quot;故事简述&quot;&gt;&lt;a href=&quot;#故事简述&quot; class=&quot;headerlink&quot; title=&quot;故事简述&quot;&gt;&lt;/a&gt;故事简述&lt;/h4&gt;&lt;p&gt;故事起源于一场误杀事件。花岗靖子和花冈美里母女俩为了躲避前夫富坚慎二，而换了新的工作，并且搬离的原来的住处。但是，富坚还是找到了他们。面对的富坚的咄咄逼人，母女俩冲动之下将富坚杀害。一筹莫展之际，她们的邻居，数学奇才石神出面帮忙处理善后。故事从这里开始了。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://arstead.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://arstead.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>将MatConvNet预训练模型转成Keras模型</title>
    <link href="https://arstead.github.io/%E6%8A%80%E6%9C%AF/Keras/convert_matconvnet_to_keras/"/>
    <id>https://arstead.github.io/技术/Keras/convert_matconvnet_to_keras/</id>
    <published>2017-03-20T13:00:58.000Z</published>
    <updated>2017-03-28T15:11:43.215Z</updated>
    
    <content type="html"><![CDATA[<p><small><em>总字数：约10000字，阅读时间：约10分钟</em></small></p>
<p>在最开始接触深度学习的时候，很经常使用MatConvNet。主要是因为里面的预训练模型比较丰富，在fine-tune的过程中能获得比较好的结果，很适合新手使用。但是随着对深度网络越来越深入之后，很多就需要自己去设计层结构，损失函数，规则项等等，这个时候MatConvNet就显得力不从心了。而keras的出现就大大简化了这一过程，良好的接口让构建模型简单快速，而且可扩展性强。对于需要深入底层的实现，也可以使用TensorFlow或Theano来实现，确实是一个很好的工具。</p>
<p>不过虽然Keras上面也有很多预训练好的模型，可以用来进行fine-tune，但是其丰富程度远没有MatConvNet的多。思来想去，决定自己写一个函数来实现MatConvNet模型对Keras模型的一个转变。</p>
<a id="more"></a>
<h4 id="读取mat文件"><a href="#读取mat文件" class="headerlink" title="读取mat文件"></a>读取mat文件</h4><p>在Python中，要读取Matlab的.mat文件需要借助Scipy库中的io模块。在Scipy.io中有一个loadmat函数，可以实现对.mat文件的读取。注：本文以vgg-face模型为例进行说明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mat_model = loadmat(&apos;vgg-face.mat&apos;, squeeze_me=True, struct_as_record=False)</div></pre></td></tr></table></figure>
<p>这里有两个参数，squeeze_me是用于将Matlab中空的二维结构压缩成一维结构，因为Matlab中常出现(1, N)的数组，所以直接读取，在Python也会保留二维结构。但实际上它并没有任何意义，反倒会因为需要做两层索引而增加编程负担，而被压缩成一维之后在后续操作中会更为便捷。struct_as_record默认是True，在这种情况下struct类型数据会被存在dict结构中。当把这个设置成False时，所有的struct数据会被当成属性，调用起来比较直观。</p>
<h4 id="前期处理"><a href="#前期处理" class="headerlink" title="前期处理"></a>前期处理</h4><p>在vgg-face.mat中，只有layers里面的内容是涉及到网络结构的，而meta中的内容是关于数据集的一些信息，在这里我们暂时用不上。</p>
<p>这里是我们需要用到的模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from scipy.io import loadmat</div><div class="line">from keras.models import Model</div><div class="line">from keras.layers import Convolution2D, MaxPooling2D, AveragePooling2D, \</div><div class="line">                        Flatten, Dense, Input, Activation</div></pre></td></tr></table></figure>
<p>然后，我们可以定义一个函数，来专门完成模型的转换功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">def convert_model_from_matconvnet(mat_model_layers, input_shape, only_architecture=False):</div></pre></td></tr></table></figure>
<p>mat_model_layers指的是MatConvNet模型中的layers数据，传入的时候只需要传入这个参数就可以了。input_shape是模型的输入大小，这个是在meta中，所以我们也单独把它提出来，作为参数传入。only_architecture是指只保留结构，而不导入权重，在个别情况下，我们可能只需要结构，而不需要预训练模型。</p>
<p>函数接口定义完之后，我们就可以开始进入细节了。首先做一些准备工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">inputs = Input(shape=input_shape)</div><div class="line">x = inputs</div><div class="line"></div><div class="line">pooling_dict = &#123;&apos;max&apos;: MaxPooling2D, &apos;avg&apos; : AveragePooling2D&#125;</div><div class="line">activation_set = [&apos;relu&apos;, &apos;sigmod&apos;, &apos;tanh&apos;, &apos;linear&apos;, &apos;softmax&apos;]</div><div class="line"></div><div class="line">is_flatten = False</div></pre></td></tr></table></figure>
<p>我们这里使用泛型模型的API来构建Keras模型，这样的好处是以后遇到了新的结构，可以很好的做扩展。其次是pooling_dict和activation_set，我们事先将pooling层类型和activation类型放置在这两个结构之中，然后内部需要调用时直接从这里找，这样在之后需要扩展的时候直接将新的层结构加到这里面就可以了。最后is_flatten是用来判断是否被flatten，在MatConvNet中，没有flatten的操作，它直接用conv层来表示全连接层，最后出来的结果用squeeze函数来压缩冗余的维度，但是在Keras并不能这样做，所以我们需要判定一下在全连接层前是否被flatten，如果没有的话我们需要添加Flatten层</p>
<h4 id="构建层"><a href="#构建层" class="headerlink" title="构建层"></a>构建层</h4><p>构建层是整个函数的核心。先将所有代码都放上来，在后面我将会一步一步详细说明实现逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">for mat_layer in mat_model_layers:</div><div class="line">    layer_type = mat_layer.type</div><div class="line">    layer_name = mat_layer.name</div><div class="line"></div><div class="line">    if layer_type == &apos;conv&apos;:</div><div class="line">        if layer_name.startswith(&apos;conv&apos;):</div><div class="line">            mat_weights = mat_layer.weights[0]</div><div class="line">            mat_bias = mat_layer.weights[1]</div><div class="line">            weights_shape = mat_weights.shape[:2]</div><div class="line">            nb_filter = mat_weights.shape[-1]</div><div class="line">            keras_weights = None if only_architecture else [mat_weights, mat_bias]</div><div class="line">            x = Convolution2D(nb_filter, weights_shape[0], weights_shape[1], </div><div class="line">                            border_mode=&apos;same&apos;, </div><div class="line">                            name=layer_name, </div><div class="line">                            weights=keras_weights)(x)</div><div class="line">        elif layer_name.startswith(&apos;fc&apos;):</div><div class="line">            if not is_flatten:</div><div class="line">                # conv layer is be used as fc layer in matconvnet, so we need to flatten in keras</div><div class="line">                # and used dense instead in keras.</div><div class="line">                mat_weights = mat_layer.weights[0]</div><div class="line">                mat_bias = mat_layer.weights[1]</div><div class="line">                weights_shape = mat_weights.shape[:2]</div><div class="line">                nb_filter = mat_weights.shape[-1]</div><div class="line">                keras_weights = None if only_architecture else [mat_weights, mat_bias]</div><div class="line">                x = Convolution2D(nb_filter, weights_shape[0], weights_shape[1], </div><div class="line">                            border_mode=&apos;valid&apos;, </div><div class="line">                            name=layer_name, </div><div class="line">                            weights=keras_weights)(x)</div><div class="line">                x = Flatten()(x)</div><div class="line">                is_flatten = True</div><div class="line">            else:</div><div class="line">                mat_weights = mat_layer.weights[0]</div><div class="line">                mat_bias = mat_layer.weights[1]</div><div class="line">                weights_shape = mat_weights.shape</div><div class="line">                nb_filter = 1</div><div class="line">                keras_weights = None if only_architecture else [mat_weights, mat_bias]</div><div class="line">                x = Dense(weights_shape[1], name=layer_name, weights=keras_weights)(x)</div><div class="line">        else:</div><div class="line">            raise TypeError(&apos;Layer name &quot;%s&quot; from matconvnet can&quot;t match keras type&apos; % layer_name)</div><div class="line"></div><div class="line">    elif layer_type == &apos;pool&apos;:</div><div class="line">        method = mat_layer.method</div><div class="line">        stride = mat_layer.stride</div><div class="line">        pool_size = mat_layer.pool</div><div class="line">        x = pooling_dict[method](pool_size, (stride, stride), name=layer_name)(x)</div><div class="line">    elif layer_type in activation_set:</div><div class="line">        x = Activation(layer_type, name=layer_name)(x)</div><div class="line">    else:</div><div class="line">        raise TypeError(&apos;%s from matconvnet not implement in keras.&apos; % layer_type)</div></pre></td></tr></table></figure>
<p>整体代码逻辑并不复杂，但是涉及一些细节处理的问题，需要详细说明一下。我们需要对每一层进行迭代。进入循环后，获取层的类型和层的名字，在MatConvNet中，层类型和层名在type和name两个属性中，这里我们可以直接获取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for mat_layer in mat_model_layers:</div><div class="line">    layer_type = mat_layer.type</div><div class="line">    layer_name = mat_layer.name</div></pre></td></tr></table></figure>
<p>获取到这两个参数之后，开始进行验证。如果是conv类型，则是MatConvNet中的卷积层，这个时候对应的层中，会有weights属性，这里就是我们需要的权重。weights是一个列表，第一个元素是filter的权重，第二个元素是bias的值。我查阅了MatConvNet的文档，里面给出他的权重是按照H<em>W</em>D*D’的结构定义的，分别代表高度、宽度、深度和卷积核数。在Keras中，卷积层只需要给定卷积核的高度、宽度和核数。深度在底层会自动进行匹配，所以我们只需要将这几个值切片出来，然后创建卷积层，并传入相关权重即可。</p>
<p>但是，这里有一点需要格外注意，因为MatConvNet中没有单独定义全连接层，其直接使用卷积层作为替换，最后结果使用squeeze函数来压缩冗余的维度。而这两种层唯一的区别在于name属性中，卷积层为’conv’开头的字样，如’conv1_1’，而全连接层以’fc’开头的字样，如’fc8’。所以这个时候我们就以name属性作为判断依据来判定是否为全连接层。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">if layer_type == &apos;conv&apos;:</div><div class="line">            if layer_name.startswith(&apos;conv&apos;):</div><div class="line">                mat_weights = mat_layer.weights[0]</div><div class="line">                mat_bias = mat_layer.weights[1]</div><div class="line">                weights_shape = mat_weights.shape[:2]</div><div class="line">                nb_filter = mat_weights.shape[-1]</div><div class="line">                keras_weights = None if only_architecture else [mat_weights, mat_bias]</div><div class="line">                x = Convolution2D(nb_filter, weights_shape[0], weights_shape[1], </div><div class="line">                                border_mode=&apos;same&apos;, </div><div class="line">                                name=layer_name, </div><div class="line">                                weights=keras_weights)(x)</div></pre></td></tr></table></figure>
<p>值得一提的是，在MatConvNet中，存在stride和padding属性来确定遍历情况。但是在Keras中却没有，Keras只提供了三种border_mode（’valid’：只在特征内遍历，不进行扩充。’same’：保持特征大小不变， ‘full’：遍历所有元素，卷积核超出特征边界的部分设置为0）。如下图所示(下图来源于深度学习Keras群@情笔M医学影像)。</p>
<img src="/技术/Keras/convert_matconvnet_to_keras/border_mode.jpg" alt="border_mode.jpg" title="">
<p>而VGGFACE模型中，所使用的卷积层均为stride=1，padding=1，即为Keras中的same模式，所以我们定义卷积层的时候直接用这个border_mode即可。</p>
<p>回过头来，如果是全连接层，我们就需要做一个判定，看是否被flatten。这里是MatConvNet设计上的一个区别，因为没有flatten层，所以它只能采用类似于全卷积的方法，定义一个卷积核与特征维度相同的卷积层，使得最后出来的特征是单维的。而这一层实际上是一个全连接层，所以MatConvNet使用’fc’字样开头的名字来定义name属性，也就是说这一个包含卷积核的全连接层。而Keras中因为有Flatten层，所以不需要考虑这么多细节问题。但是在这里，我们就需要依照MatConvNet的结构，对第一个遇到的全连接层，再多定义一个卷积层，并且将border_mode设置为valid（相当于stride为1）。</p>
<p>其次还有一个问题是权重维度，因为对于全连接层而言，权重维度为2，但是对于卷积层而言，则是4。所以对于其后的全连接层，它是按照input_node*output_node的结构来定义的，所以我们取权重的第二维大小作为全连接层的节点数即可。最后对未实现的结构抛出异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">elif layer_name.startswith(&apos;fc&apos;):</div><div class="line">    if not is_flatten:</div><div class="line">        # conv layer is be used as fc layer in matconvnet, so we need to flatten in keras</div><div class="line">        # and used dense instead in keras.</div><div class="line">        mat_weights = mat_layer.weights[0]</div><div class="line">        mat_bias = mat_layer.weights[1]</div><div class="line">        weights_shape = mat_weights.shape[:2]</div><div class="line">        nb_filter = mat_weights.shape[-1]</div><div class="line">        keras_weights = None if only_architecture else [mat_weights, mat_bias]</div><div class="line">        x = Convolution2D(nb_filter, weights_shape[0], weights_shape[1], </div><div class="line">                    border_mode=&apos;valid&apos;, </div><div class="line">                    name=layer_name, </div><div class="line">                    weights=keras_weights)(x)</div><div class="line">        x = Flatten()(x)</div><div class="line">        is_flatten = True</div><div class="line">    else:</div><div class="line">        mat_weights = mat_layer.weights[0]</div><div class="line">        mat_bias = mat_layer.weights[1]</div><div class="line">        weights_shape = mat_weights.shape</div><div class="line">        keras_weights = None if only_architecture else [mat_weights, mat_bias]</div><div class="line">        x = Dense(weights_shape[1], name=layer_name, weights=keras_weights)(x)</div><div class="line">else:</div><div class="line">    raise TypeError(&apos;Layer name &quot;%s&quot; from matconvnet can&quot;t match keras type&apos; % layer_name)</div></pre></td></tr></table></figure>
<p>然后就是对pooling层和activation层的一个添加，这部分比较好理解。由于我们事先将pooling层类型和activation类型添加入了pooling_dict和activation_set中，所以检测和添加过程都比较简单。需要提一下的是，Keras中的pooling层需要给出pooling size和stride，这两个参数分别对应MatConvNet中的pool和stride属性，其中stride属性在MatConvNet中是一个数，因为它在两个方向上的遍历步长都是一样的，而Keras需要分别给出，所以我们多复制一个就好了。</p>
<p>最后对未实现的层抛出一个异常。如果之后又新的模型出来，需要转变新的层结构，只需要在这里的分支结构添加一个新的分支即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">elif layer_type == &apos;pool&apos;:</div><div class="line">    method = mat_layer.method</div><div class="line">    stride = mat_layer.stride</div><div class="line">    pool_size = mat_layer.pool</div><div class="line">    x = pooling_dict[method](pool_size, (stride, stride), name=layer_name)(x)</div><div class="line">elif layer_type in activation_set:</div><div class="line">    x = Activation(layer_type, name=layer_name)(x)</div><div class="line">else:</div><div class="line">    raise TypeError(&apos;%s from matconvnet not implement in keras.&apos; % layer_type)</div></pre></td></tr></table></figure>
<p>最后，创建用输入和输出创建整个模型并返回，就完成了。</p>
<p>‘’’<br>    model = Model(input=inputs, output=x)<br>    return model<br>‘’’</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>在MatConvNet中，给了每一个模型的测试程序，这里我们就仿照着他的测试程序，写一个Keras版本的，对了，在meta中，包含了整个模型的元信息，包括输入大小，训练集统计数据，标签表述等等。需要的话可以去对应的.mat文件中查看。</p>
<p>‘’’<br>import os<br>from PIL import Image</p>
<p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    mat_model = loadmat(os.path.join(‘..’, ‘matconvnet_model’, ‘vgg-face.mat’), squeeze_me=True, struct_as_record=False)<br>    model = convert_model_from_matconvnet(mat_model[‘layers’], input_shape=(224, 224, 3))</p>
<pre><code>im = Image.open(&apos;Aamir_Khan_March_2015.jpg&apos;)
im = im.crop(box=(0, 0, im.size[0], 250))
im = im.resize(size=(224, 224))
im = np.array(im, dtype=np.float32) - mat_model[&apos;meta&apos;].normalization.averageImage

score = model.predict(np.array(im)[np.newaxis, :])
idx = np.argmax(score)
print(mat_model[&apos;meta&apos;].classes.description[idx])
</code></pre><p>‘’’</p>
<p>最后输出结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Aamir_Khan</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;small&gt;&lt;em&gt;总字数：约10000字，阅读时间：约10分钟&lt;/em&gt;&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;在最开始接触深度学习的时候，很经常使用MatConvNet。主要是因为里面的预训练模型比较丰富，在fine-tune的过程中能获得比较好的结果，很适合新手使用。但是随着对深度网络越来越深入之后，很多就需要自己去设计层结构，损失函数，规则项等等，这个时候MatConvNet就显得力不从心了。而keras的出现就大大简化了这一过程，良好的接口让构建模型简单快速，而且可扩展性强。对于需要深入底层的实现，也可以使用TensorFlow或Theano来实现，确实是一个很好的工具。&lt;/p&gt;
&lt;p&gt;不过虽然Keras上面也有很多预训练好的模型，可以用来进行fine-tune，但是其丰富程度远没有MatConvNet的多。思来想去，决定自己写一个函数来实现MatConvNet模型对Keras模型的一个转变。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://arstead.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Keras" scheme="https://arstead.github.io/categories/%E6%8A%80%E6%9C%AF/Keras/"/>
    
    
      <category term="技术" scheme="https://arstead.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Keras源码解析(1)-入门</title>
    <link href="https://arstead.github.io/%E6%8A%80%E6%9C%AF/Keras/keras_source_code_analysis_1_introduction/"/>
    <id>https://arstead.github.io/技术/Keras/keras_source_code_analysis_1_introduction/</id>
    <published>2017-03-18T11:54:58.000Z</published>
    <updated>2017-03-28T03:17:38.152Z</updated>
    
    <content type="html"><![CDATA[<p><small><em>总字数：约12000字，阅读时间：约15分钟</em></small></p>
<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>刚开始接触机器学习的时候，曾经试过用python写过一个简单的MLP（Multi-Layer Perceptron），其中仅仅只是实现了简单的Gradient Descent算法，激活函数上也只涉及了Sigmod激活函数。在这之后的很多研究中，都是用的现成的算法库在跑，完全接触不到实现方法，编程能力也急剧下降。所以趁着现在有点时间，认真学习一下别人是怎么样实现深度学习方法的。由于我一直使用的是python语言，而且我在入门深度学习的时候也是从Keras这个库开始的。自从被TensorFlow列为官网API之后，Keras使用的人也极具上升。所以决定从Keras源码开始看起，学习一下别人是如何实现深度学习框架的。</p>
<p>由于我是即兴记录的，目前还没有任何的目标。所以可能会出现结构上有些凌乱，等我都掌握了之后，我再做整理吧。如果发现了我在分析的过程中存在错误或者不足，希望大家能给我留言，欢迎指正。</p>
<p>在发表之前写了一些内容，但是自低向上写的。结果发现自低向上分析实在有点困难，要直接把底层结构讲清楚确实很困难。所以决定改一改策略，采用自顶向下的方式写，先分析基础构建，再深入底层分析运作原理。注：在代码讲解过程中，我将一些不必要的空行，包导入等不影响整体介绍的部分删掉了，将非重点讲解的内容修改为pass(并不是这部分没有代码)，在部分位置添加了一些标识以定位代码。</p>
<p>我在开始写这个系列的时候，Keras最新版本还是1.2.2，现在已经出了2.X的版本了，不过核心框架没有变动，仅仅只是做了一些接口的改变，所以依旧可以根据1.2.2版本进行分析。Keras 2改动部分可以在这篇<a href="https://blog.keras.io/introducing-keras-2.html" target="_blank" rel="external">博文(Introducing Keras 2)</a>上查看。</p>
<a id="more"></a>
<h4 id="文档结构"><a href="#文档结构" class="headerlink" title="文档结构"></a>文档结构</h4><p>我们先来看看Keras下的文档结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">|-- docs               #说明文档</div><div class="line">|-- examples           #应用示例</div><div class="line">|-- test               #测试文件</div><div class="line">|-- keras                  #源码核心</div><div class="line">|  |-- backend             #底层backend</div><div class="line">|  |-- datasets            #数据获取源码</div><div class="line">|  |-- engine              #核心工具</div><div class="line">|  |-- layers              #层源码</div><div class="line">|  |-- legacy              #遗留源码</div><div class="line">|  |-- preprocessing       #预处理函数</div><div class="line">|  |-- utils               #实用工具</div><div class="line">|  |-- wrappers            #scikit-learn 封装类</div><div class="line">|  |-- activations.py      #可用的激活函数</div><div class="line">|  |-- callbacks.py        #回调函数</div><div class="line">|  |-- constraints.py      #权重约束项，如非零约束等</div><div class="line">|  |-- initializations.py  #初始化方法</div><div class="line">|  |-- metrics.py          #度量方法</div><div class="line">|  |-- models.py           #包含Model和Sequential模型，以及各种存取方法</div><div class="line">|  |-- objectives.py       #objectives function，也就是loss function</div><div class="line">|  |-- optimizers.py       #优化方法，如SGD，Adam等</div><div class="line">|  |-- regularizers.py     #规则项，如L1，L2等规则项</div></pre></td></tr></table></figure>
<p>实际上，对于在深度学习这个模块里面，我们主要关注的是engine文件夹中的内容，这里面包含了关于model、layer、node的实现方式，也就是最底层的内容。而我们在应用当中，主要使用的Keras文件夹下.py的文件，其中常用的Sequential模型在models.py中实现，各种Optimizer类在optimizers.py中实现，各种激活函数在activations.py等等。这些内容我们以后慢慢来看，我们先从底层开始看起，看看Keras的底层是如何实现可扩展结构的。</p>
<h4 id="从一个例子开始"><a href="#从一个例子开始" class="headerlink" title="从一个例子开始"></a>从一个例子开始</h4><p>首先，从一个示例程序入手，开始解析Keras。我从examples文件夹中挑选mnist_cnn<br>.py作为我们上手的第一个程序。选择它的主要原因是因为它整体框架比较简洁，而且包含了Keras常用的构建。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"># examples/mnist_cnn.py</div><div class="line">&apos;&apos;&apos;Trains a simple convnet on the MNIST dataset.</div><div class="line">Gets to 99.25% test accuracy after 12 epochs</div><div class="line">(there is still a lot of margin for parameter tuning).</div><div class="line">16 seconds per epoch on a GRID K520 GPU.</div><div class="line">&apos;&apos;&apos;</div><div class="line">batch_size = 128</div><div class="line">nb_classes = 10</div><div class="line">nb_epoch = 12</div><div class="line"></div><div class="line"># input image dimensions</div><div class="line">img_rows, img_cols = 28, 28</div><div class="line"># number of convolutional filters to use</div><div class="line">nb_filters = 32</div><div class="line"># size of pooling area for max pooling</div><div class="line">pool_size = (2, 2)</div><div class="line"># convolution kernel size</div><div class="line">kernel_size = (3, 3)</div><div class="line"></div><div class="line"># the data, shuffled and split between train and test sets</div><div class="line">(X_train, y_train), (X_test, y_test) = mnist.load_data()</div><div class="line"></div><div class="line">if K.image_dim_ordering() == &apos;th&apos;:</div><div class="line">    X_train = X_train.reshape(X_train.shape[0], 1, img_rows, img_cols)</div><div class="line">    X_test = X_test.reshape(X_test.shape[0], 1, img_rows, img_cols)</div><div class="line">    input_shape = (1, img_rows, img_cols)</div><div class="line">else:</div><div class="line">    X_train = X_train.reshape(X_train.shape[0], img_rows, img_cols, 1)</div><div class="line">    X_test = X_test.reshape(X_test.shape[0], img_rows, img_cols, 1)</div><div class="line">    input_shape = (img_rows, img_cols, 1)</div><div class="line"></div><div class="line">X_train = X_train.astype(&apos;float32&apos;)</div><div class="line">X_test = X_test.astype(&apos;float32&apos;)</div><div class="line">X_train /= 255</div><div class="line">X_test /= 255</div><div class="line">print(&apos;X_train shape:&apos;, X_train.shape)</div><div class="line">print(X_train.shape[0], &apos;train samples&apos;)</div><div class="line">print(X_test.shape[0], &apos;test samples&apos;)</div><div class="line"></div><div class="line"># convert class vectors to binary class matrices</div><div class="line">Y_train = np_utils.to_categorical(y_train, nb_classes)</div><div class="line">Y_test = np_utils.to_categorical(y_test, nb_classes)</div><div class="line">model = Sequential()</div><div class="line">model.add(Convolution2D(nb_filters, kernel_size[0], kernel_size[1],</div><div class="line">                        border_mode=&apos;valid&apos;,</div><div class="line">                        input_shape=input_shape))</div><div class="line">model.add(Activation(&apos;relu&apos;))</div><div class="line">model.add(Convolution2D(nb_filters, kernel_size[0], kernel_size[1]))</div><div class="line">model.add(Activation(&apos;relu&apos;))</div><div class="line">model.add(MaxPooling2D(pool_size=pool_size))</div><div class="line">model.add(Dropout(0.25))</div><div class="line">model.add(Flatten())</div><div class="line">model.add(Dense(128))</div><div class="line">model.add(Activation(&apos;relu&apos;))</div><div class="line">model.add(Dropout(0.5))</div><div class="line">model.add(Dense(nb_classes))</div><div class="line">model.add(Activation(&apos;softmax&apos;))</div><div class="line">model.compile(loss=&apos;categorical_crossentropy&apos;,</div><div class="line">              optimizer=&apos;adadelta&apos;,</div><div class="line">              metrics=[&apos;accuracy&apos;])</div><div class="line">model.fit(X_train, Y_train, batch_size=batch_size, nb_epoch=nb_epoch,</div><div class="line">          verbose=1, validation_data=(X_test, Y_test))</div><div class="line">score = model.evaluate(X_test, Y_test, verbose=0)</div><div class="line">print(&apos;Test score:&apos;, score[0])</div><div class="line">print(&apos;Test accuracy:&apos;, score[1])</div></pre></td></tr></table></figure>
<p>首先定义了这个模型的一些超参数，batch size,input size之类的。其次是获取数据。这里我们需要重点提一下了，在Keras的datasets模块中，包含了6个数据集(cifar, cifar10, cifar100, imdb, mnist, reuters)，这些数据集不是一开始就存在的，而是在使用的时候才去下载的，不过只需要下载一次就可以了，之后它会在指定的文件夹中寻找。我们看看它是怎么实现的。</p>
<h4 id="数据集下载"><a href="#数据集下载" class="headerlink" title="数据集下载"></a>数据集下载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"># keras/datasets/mnist.py</div><div class="line">def load_data(path=&apos;mnist.pkl.gz&apos;):</div><div class="line">    &quot;&quot;&quot;Loads the MNIST dataset.</div><div class="line">    # Arguments</div><div class="line">        path: path where to cache the dataset locally</div><div class="line">            (relative to ~/.keras/datasets).</div><div class="line">    # Returns</div><div class="line">        Tuple of Numpy arrays: `(x_train, y_train), (x_test, y_test)`.</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    path = get_file(path, origin=&apos;https://s3.amazonaws.com/img-datasets/mnist.pkl.gz&apos;)</div><div class="line">    if path.endswith(&apos;.gz&apos;):</div><div class="line">        f = gzip.open(path, &apos;rb&apos;)</div><div class="line">    else:</div><div class="line">        f = open(path, &apos;rb&apos;)</div><div class="line">    if sys.version_info &lt; (3,):</div><div class="line">        data = cPickle.load(f)</div><div class="line">    else:</div><div class="line">        data = cPickle.load(f, encoding=&apos;bytes&apos;)</div><div class="line">    f.close()</div><div class="line">    return data  # (x_train, y_train), (x_test, y_test)</div></pre></td></tr></table></figure>
<p>load_data函数接受一个参数path，表示存储的地址。关于这个参数，我觉得这是Keras设计上的一个失误。无论是文件名还是注释都表示这是一个地址，但实际的默认给出的参数却是文件名，然后又在注释中又添加了一段(relative to ~/.keras/datasets)，表示实际的默认存储位置为用户目录下的一个隐藏文件中，确实让人很不解。继续往下看，从get_file的URL地址我们可以看出，Keras将数据文件寄托在了Amazon AWS上面。对于一些小一点的数据文件，直接用其自动下载功能不会存在太大的问题。但是对于一些比较大的文件，直接下载很容易断线，而默认是不支持断点续传的。这个时候我们就可以在源码里面找到它的下载URL，然后使用其他的下载工具进行下载，然后拷贝到默认的文件夹(~/.keras/datasets)中即可。</p>
<p>之后是检测是否为压缩包，若是则读取压缩文件，否则直接读取(可以看出这个应该是早期设计的函数，解压部分现在已经被集成到了<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这里我们再深入一点，看看```get_file```函数的运作方式。这个函数很重要，Keras中涉及到下载文件功能的部分均是由这个函数实现的。它保存在utils\data_utils.py文件中。</div></pre></td></tr></table></figure></p>
<h1 id="keras-utils-data-utils-py"><a href="#keras-utils-data-utils-py" class="headerlink" title="keras/utils/data_utils.py"></a>keras/utils/data_utils.py</h1><p>def get_file(fname, origin, untar=False,<br>             md5_hash=None, cache_subdir=’datasets’):<br>    “””Downloads a file from a URL if it not already in the cache.<br>    Passing the MD5 hash will verify the file after download<br>    as well as if it is already present in the cache.</p>
<pre><code># Arguments
    fname: name of the file
    origin: original URL of the file
    untar: boolean, whether the file should be decompressed
    md5_hash: MD5 hash of the file for verification
    cache_subdir: directory being used as the cache
# Returns
    Path to the downloaded file
&quot;&quot;&quot;
######################## (1) start ########################
datadir_base = os.path.expanduser(os.path.join(&apos;~&apos;, &apos;.keras&apos;))
if not os.access(datadir_base, os.W_OK):
    datadir_base = os.path.join(&apos;/tmp&apos;, &apos;.keras&apos;)
datadir = os.path.join(datadir_base, cache_subdir)
if not os.path.exists(datadir):
    os.makedirs(datadir)
######################### (1) end #########################
if untar:
    untar_fpath = os.path.join(datadir, fname)
    fpath = untar_fpath + &apos;.tar.gz&apos;
else:
    fpath = os.path.join(datadir, fname)
######################## (2) start ########################
download = False
if os.path.exists(fpath):
    # File found; verify integrity if a hash was provided.
    if md5_hash is not None:
        if not validate_file(fpath, md5_hash):
            print(&apos;A local file was found, but it seems to be &apos;
                  &apos;incomplete or outdated.&apos;)
            download = True
else:
    download = True
if download:
    print(&apos;Downloading data from&apos;, origin)
    progbar = None

    def dl_progress(count, block_size, total_size, progbar=None):
        if progbar is None:
            progbar = Progbar(total_size)
        else:
            progbar.update(count * block_size)

    error_msg = &apos;URL fetch failure on {}: {} -- {}&apos;
    try:
        try:
            urlretrieve(origin, fpath,
                        functools.partial(dl_progress, progbar=progbar))
        except URLError as e:
            raise Exception(error_msg.format(origin, e.errno, e.reason))
        except HTTPError as e:
            raise Exception(error_msg.format(origin, e.code, e.msg))
    except (Exception, KeyboardInterrupt) as e:
        if os.path.exists(fpath):
            os.remove(fpath)
        raise
    progbar = None
######################### (2) end #########################
if untar:
    if not os.path.exists(untar_fpath):
        print(&apos;Untaring file...&apos;)
        tfile = tarfile.open(fpath, &apos;r:gz&apos;)
        try:
            tfile.extractall(path=datadir)
        except (Exception, KeyboardInterrupt) as e:
            if os.path.exists(untar_fpath):
                if os.path.isfile(untar_fpath):
                    os.remove(untar_fpath)
                else:
                    shutil.rmtree(untar_fpath)
            raise
        tfile.close()
    return untar_fpath
return fpath
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这个函数包含五个参数，fname(文件名)，origin(源URL)，untar(是否解压)，md5_hash(md5验证)，cache_subdir(存储子文件夹)。这个函数首先获取一个合法的下载地址(1)，如果根目录下.keras文件可写，则以这个路径为默认路径，否则默认路径改为/tmp/.keras。这里貌似有个bug，第一部分使用```os.path.expanduser```能兼容Windows、Linux等多种平台，但是对于后面直接使用```os.path.join(&apos;/tmp&apos;, &apos;.keras&apos;)```，貌似在Windows系统下面是不存在这个路径的。</div><div class="line"></div><div class="line">其后检测是否需要解压，这个功能应该是后来加的，在```mnist.load_data```函数中还留有需要外部解压的痕迹。对于需要解压的情况，函数的最后面对其进行了一个解压操作，并返回解压后的地址。</div><div class="line"></div><div class="line">这个函数的核心部分就是下载(2)。首先定义一个布尔变量download(注意:这个变量表示是否需要下载，而非是否已经下载)，然后检验是否需要下载，两种情况需要下载：文件不存在或者文件存在但MD5验证不正确。下载的过程就比较简单了，先定义了一个用于显示下载进度条的回调函数```dl_progress```，然后调取```urlretrieve```函数进行下载。我很喜欢这一部分的异常处理，在内部截获两种不同的异常，然后使用通用异常进行显示，并且将用户终止异常添加进去，还处理了下载失败后的损坏文件，避免出错。不过这里还是存在一个问题，这里缺少了MD5验证流程。实际上对于一个严谨的程序，应当将验证流程放置在整个程序的最末尾，以防止中间过程出现的不可预见性错误。所以这里应该适当调整MD5验证的位置，以防止意外情况出现。</div><div class="line"></div><div class="line">最后小小的提一下```urlretrieve```函数，主要是觉得这种处理方式很优雅。</div></pre></td></tr></table></figure>
<h1 id="keras-utils-data-utils-py-1"><a href="#keras-utils-data-utils-py-1" class="headerlink" title="keras/utils/data_utils.py"></a>keras/utils/data_utils.py</h1><p>if sys.version_info[0] == 2:<br>    def urlretrieve(url, filename, reporthook=None, data=None):<br>        pass<br>else:<br>    from six.moves.urllib.request import urlretrieve<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">因为在Python 2.X的版本中，urlretrieve存在一些问题，所以对于这个版本作者自己写了一个获取程序，而对于Python 3.X就直接从外部库导入。在保持接口相同的情况下，就可以兼容两个版本，而且不需要额外的修改。</div><div class="line"></div><div class="line">#### 一些小工具</div><div class="line"></div><div class="line">回到上面的示例程序，获取完了数据之后，我们又可以开心的继续往下走了。下面是检验backend维度顺序，在Theano中默认维度顺序为(depth, row, column)，而在TensorFlow中为(row, column, depth)，所以这里要加以区分。之后就是做一些简单的数据预处理，这里直接跳过。这一小节重点要讲的是```to_categorical```函数，这个函数在Keras中经常使用到，用于做标签转换的。</div><div class="line"></div><div class="line">在神经网络中，当我们要计算交叉熵的时候，我们需要将输出节点个数定为类别数C。并且将每一个样本label的维度转换为C维，标签值对应位置设为1，其余为0。这个时候就需要用到```to_categorical```函数了。</div></pre></td></tr></table></figure></p>
<h1 id="keras-utils-np-utils-py"><a href="#keras-utils-np-utils-py" class="headerlink" title="keras/utils/np_utils.py"></a>keras/utils/np_utils.py</h1><p>def to_categorical(y, nb_classes=None):<br>    “””Converts a class vector (integers) to binary class matrix.<br>    E.g. for use with categorical_crossentropy.</p>
<pre><code># Arguments
    y: class vector to be converted into a matrix
        (integers from 0 to nb_classes).
    nb_classes: total number of classes.
# Returns
    A binary matrix representation of the input.
&quot;&quot;&quot;
y = np.array(y, dtype=&apos;int&apos;).ravel()
if not nb_classes:
    nb_classes = np.max(y) + 1
n = y.shape[0]
categorical = np.zeros((n, nb_classes))
categorical[np.arange(n), y] = 1
return categorical
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">实际上，这个函数的实现特别简单，就是获取类别数C，然后创建一个NxC维的零矩阵，然后将对应值设置为1。这里想提一下的是，它的类别数获取是根据标签值中的最大值加一来获取的，也就是说原始标签一定要从0开始取值。否则会出现未定义的类别标签。</div><div class="line"></div><div class="line">当然啦，这里还有一个反向操作的工具，```probas_to_classes```函数</div></pre></td></tr></table></figure>
<p>def probas_to_classes(y_pred):<br>    if len(y_pred.shape) &gt; 1 and y_pred.shape[1] &gt; 1:<br>        return categorical_probas_to_classes(y_pred)<br>    return np.array([1 if p &gt; 0.5 else 0 for p in y_pred])</p>
<p>def categorical_probas_to_classes(p):<br>    return np.argmax(p, axis=1)<br>```</p>
<p>实际上，<code>categorical_probas_to_classes</code>函数才是<code>to_categorical</code>函数的逆向操作，不过作者考虑到两类识别的兼容性问题，在其上又加了一个维度判断，所以我们直接用<code>probas_to_classes</code>函数就好了。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>本节主要讲了一下主体框架，然后以一个例子入手，分析了数据下载模块和两个实用的类别转换小工具。下一个章节将重点分析网络模型建立。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;small&gt;&lt;em&gt;总字数：约12000字，阅读时间：约15分钟&lt;/em&gt;&lt;/small&gt;&lt;/p&gt;
&lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;刚开始接触机器学习的时候，曾经试过用python写过一个简单的MLP（Multi-Layer Perceptron），其中仅仅只是实现了简单的Gradient Descent算法，激活函数上也只涉及了Sigmod激活函数。在这之后的很多研究中，都是用的现成的算法库在跑，完全接触不到实现方法，编程能力也急剧下降。所以趁着现在有点时间，认真学习一下别人是怎么样实现深度学习方法的。由于我一直使用的是python语言，而且我在入门深度学习的时候也是从Keras这个库开始的。自从被TensorFlow列为官网API之后，Keras使用的人也极具上升。所以决定从Keras源码开始看起，学习一下别人是如何实现深度学习框架的。&lt;/p&gt;
&lt;p&gt;由于我是即兴记录的，目前还没有任何的目标。所以可能会出现结构上有些凌乱，等我都掌握了之后，我再做整理吧。如果发现了我在分析的过程中存在错误或者不足，希望大家能给我留言，欢迎指正。&lt;/p&gt;
&lt;p&gt;在发表之前写了一些内容，但是自低向上写的。结果发现自低向上分析实在有点困难，要直接把底层结构讲清楚确实很困难。所以决定改一改策略，采用自顶向下的方式写，先分析基础构建，再深入底层分析运作原理。注：在代码讲解过程中，我将一些不必要的空行，包导入等不影响整体介绍的部分删掉了，将非重点讲解的内容修改为pass(并不是这部分没有代码)，在部分位置添加了一些标识以定位代码。&lt;/p&gt;
&lt;p&gt;我在开始写这个系列的时候，Keras最新版本还是1.2.2，现在已经出了2.X的版本了，不过核心框架没有变动，仅仅只是做了一些接口的改变，所以依旧可以根据1.2.2版本进行分析。Keras 2改动部分可以在这篇&lt;a href=&quot;https://blog.keras.io/introducing-keras-2.html&quot;&gt;博文(Introducing Keras 2)&lt;/a&gt;上查看。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://arstead.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Keras" scheme="https://arstead.github.io/categories/%E6%8A%80%E6%9C%AF/Keras/"/>
    
    
      <category term="技术" scheme="https://arstead.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>用Sublime Text 3打造一个完美的python工作环境</title>
    <link href="https://arstead.github.io/%E6%8A%80%E6%9C%AF/Python/build_python_environment_with_sublime_text/"/>
    <id>https://arstead.github.io/技术/Python/build_python_environment_with_sublime_text/</id>
    <published>2017-02-26T06:00:58.000Z</published>
    <updated>2017-03-28T15:11:22.364Z</updated>
    
    <content type="html"><![CDATA[<p><small><em>总字数：约3600字，阅读时间：约7分钟</em></small></p>
<p>自从学习了Python之后，一直想找一个好的Python IDE环境，但是一直没有找到心仪的。我认为，程序员一定要对自己好一点，每天面对的编程界面一定要赏心悦目，不然如何面对一天的工作。Pycharm的工作界面略显难看，换了各种主题都没有找到合适的，而且Pycharm实在有点大，很多功能用不上，却让运行变得很卡。也曾经使用过一段时间VS (visual studio 2015)，对于曾经的C++程序员而言，VS的用户界面还是让我觉得很舒心的，但是VS新接入python时间不长，出现的很多问题很难找到合适的解决方案。还用过Eclipse+pydev的方式，但是我在学习Java的时候就觉得Eclipse的界面真的不是一般的难看。最后我放弃了所有的IDE，用Sublime Text 3来编写python程序，然后直接内嵌一个编译器来实现查看编译结果。但是每次调试的方法都是用print各种变量的方式来看，效率低下。终于，我找到了一个合适的插件，能方便的调用PDB调试程序，现在写Python整个人都是开心的。</p>
<h4 id="Sublime-Text-3"><a href="#Sublime-Text-3" class="headerlink" title="Sublime Text 3"></a>Sublime Text 3</h4><p><a href="https://www.sublimetext.com/3" target="_blank" rel="external">ST3 (Sublime Text 3)</a> 是一个跨平台的文本编辑器，以其丰富的快捷键和灵活的插件著称，使用起来相当的方便。而且我认为，ST3是我见过最漂亮的文本编辑器。这个编译器自带了很多的编程语言的高亮显示，C/C++，Python，Java，Matlab等等。在这个界面的吸引下，我决定转投ST3的旗下。</p>
<img src="/技术/Python/build_python_environment_with_sublime_text/main_UI.png" alt="main_UI.png" title="">
<p>可以看到，中间是主要的编程界面，左边是工作目录，右边上面是PDB的调试界面，右边下面是Python的交互式界面。将编程界面用来专心写程序，程序的编写过程中如果遇到什么语言方面或者库内容方面的问题，可以在右下角的交互式界面中进行查看。代码编写完之后，可以在右上角用PDB进行调试，而且在调试的时候也可以很方便的查看代码。并且可以根据工作目录来查看工程下其他的源码。在ST3中，其可以通过右键跳转到函数的定义之中，可以方便的查看函数内容。并在结合ST3中自带的各种快捷键，编码效率相当高。有兴趣的同学可以看看这份<a href="https://docs.sublimetext.info/en/latest/index.html" target="_blank" rel="external">非官方教程</a>，和它的<a href="http://sublime-text.readthedocs.io/en/latest/getting_started/install.html" target="_blank" rel="external">中文版非官方教程</a></p>
<p>具体的安装方法在教程里面都有，可以在里面看，安装这个不是我要讲的主要内容，所以在这就不提了。遇到问题的话可以谷歌一下，基本上没有什么问题。</p>
<a id="more"></a>
<h4 id="SublimeREPL"><a href="#SublimeREPL" class="headerlink" title="SublimeREPL"></a>SublimeREPL</h4><p><a href="https://sublimerepl.readthedocs.io/en/latest/" target="_blank" rel="external">SublimeREPL</a>是ST中的一个插件，它可以让我们在ST中运行解释器（REPL），而且对Python还有特别的支持，能运行选中的代码并且启动PDB调试。</p>
<p>我们可以使用Package Control来安装这个，在ST3中使用快捷键Ctrl+Shift+P，调出Package Control界面，不想用快捷键的可以在Preferences-&gt;Package Control中调出。在输入框输入Install Package。</p>
<img src="/技术/Python/build_python_environment_with_sublime_text/pcip.png" alt="pcip.png" title="">
<p>回车之后需要等待一下，ST3需要点时间来检索安装库。完成了之后会出来一个插件检索框。在里面输入SublimeREPL，然后回车安装即可。但是有时候会出现找不到这个库的情况。这个时候可以去<a href="https://github.com/wuub/SublimeREPL" target="_blank" rel="external">SublimeREPL的github</a>上面下载源码，然后解压到ST3的包目录(./User/AppData/Roaming/Sublime Text 3/Package)中。</p>
<p>安装好了之后，可以在ST3中Tools-&gt;SublimeREPL-&gt;Python看到一些Python的启动选项，可以点开其中的Python，这个会调用系统中的Python解释器，并在ST3中呈现。也可以写一两个Python程序试一下其他的功能，里面有RUN current file，PDB current file等等。这样我们就可以在ST3中编写Python，并且可以直接调试。</p>
<p>但是，每次都要点击这么多按钮，确实比较麻烦，我们来设置几个快捷键，让整个操作便捷一点。进入快捷键绑定界面，Preferences-&gt;Key Bindings调出ST3的快捷键绑定界面。在User那个文件中加入下面这些代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">    &#123; &quot;keys&quot;: [&quot;f1&quot;], &quot;caption&quot;: &quot;SublimeREPL: Python - RUN current file&quot;, &quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;: &#123;&quot;id&quot;: &quot;repl_python_run&quot;, &quot;file&quot;: &quot;config/Python/Main.sublime-menu&quot;&#125;&#125;, </div><div class="line">    &#123; &quot;keys&quot;: [&quot;f2&quot;], &quot;caption&quot;: &quot;SublimeREPL: Python - PDB current file&quot;, &quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;: &#123;&quot;id&quot;: &quot;repl_python_pdb&quot;, &quot;file&quot;: &quot;config/Python/Main.sublime-menu&quot;&#125;&#125;,</div><div class="line">    &#123; &quot;keys&quot;: [&quot;f3&quot;], &quot;caption&quot;: &quot;SublimeREPL: Python - Python&quot;, &quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;: &#123;&quot;id&quot;: &quot;repl_python&quot;, &quot;file&quot;: &quot;config/Python/Main.sublime-menu&quot;&#125;&#125;</div><div class="line">]</div></pre></td></tr></table></figure>
<p>这个可以根据自己的喜好来添加，我设置的是F1是运行当前文件，F2是用PDB调试程序，F3是调出交互式Python编译器。这样，基本的环境就搭建完了。</p>
<h4 id="SublimeLinter-pep8"><a href="#SublimeLinter-pep8" class="headerlink" title="SublimeLinter-pep8"></a>SublimeLinter-pep8</h4><p><a href="https://github.com/SublimeLinter/SublimeLinter-pep8" target="_blank" rel="external">SublimeLinter-pep8</a>是一个python代码样式的检测工具，可以用于修正python代码的书写方法，能让自己的代码看上去更加清爽一点。</p>
<p>同样，这个插件可以使用Package Control来进行安装，在Install Package中输入SublimeLinter-pep8，然后安装即可。安装完后，选取需要修改样式的代码，点击鼠标右键，可以看到有一个AutoPEP8选项，然后点击Format即可。这款插件还有显示样式错误，设置快捷键等等功能，但是由于我有自己的代码风格，所以用这个比较少，只是在无法确定一些风格怎么处理的时候才会用到，所以也就懒得继续探索了。想要继续探索的同学可以谷歌一下。</p>
<h4 id="SFTP"><a href="#SFTP" class="headerlink" title="SFTP"></a>SFTP</h4><p><a href="https://wbond.net/sublime_packages/sftp" target="_blank" rel="external">SFTP</a>是一款特别棒的远程同步插件。很多时候我们需要将写完的代码同步到服务器上去执行，传统方式就是切换到FTP上，然后将代码拷到服务器上，然后回到远程控制台去执行。这样操作相当繁琐。然后我找到了SFTP能实现远程代码同步的插件。最后的结果大概像下面这样。这个插件反馈很友好，能及时反馈同步的文件及结果。</p>
<img src="/技术/Python/build_python_environment_with_sublime_text/SFTP.png" alt="SFTP.png" title="">
<p>具体安装方式跟所有插件一样，使用Package Control，选择SFTP即可。不过这个部署的服务器好像需要科学上网才能连接上，而且这个服务器的地址不在在线PCA列表中。我一开始下了很久都提示连接失败，直到我使用全局代理才成功下载。</p>
<p>安装完后，选择File-&gt;SFTP/FTP-&gt;Set up server，配置自己的服务器信息。然后保存，保存的时候他的默认路劲是user目录下的SFTP文件夹，没有默认文件名，我们可以以工程名或者服务器名来命名这个文件。</p>
<p>完成之后选择你要同步的文件夹，在边栏选择你要同步的文件或文件夹，右键SFTP/FTP-&gt;Map to Remote。这个时候会在当前文件夹下创建一个配置文档，主要是一些同步操作的配置。具体参数的细节可以在<a href="https://wbond.net/sublime_packages/sftp/settings" target="_blank" rel="external">官网SFTP</a>找到，我的配置如下图所示。</p>
<img src="/技术/Python/build_python_environment_with_sublime_text/SFTP-setting.png" alt="SFTP-setting.png" title="">
<p>保存好配置之后，再右键SFTP/FTP里面的选项变成了同步操作，这样他就会自动同步了。</p>
<h4 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h4><p>正常的ST3界面只有单纯的输入界面和选项卡。调试或者运行会出现新的选项卡，相互之间切换也是一件很麻烦的事情，所以需要改变一下布局。</p>
<p>在ST3的View-&gt;Layout中有很多布局形式，最开始的时候，我使用的是Grid的四格布局。但是我觉得显示的效果并不是很好，每个输入框太小，代码都看不全。</p>
<img src="/技术/Python/build_python_environment_with_sublime_text/grid_layout.png" alt="grid_layout.png" title="">
<p>其他的布局格式看上去也不是很适用，所以想在网上找一个好的布局方式。但是ST3对布局方式好像不能定制化。但是在谷歌的过程中，我发现了一种T字型的三个布局，相当的不错。设置方式是这样的，先选择双列布局View-&gt;Layout-&gt;Columns:2，然后增加文件分组View-&gt;Groups-&gt;Move File to New Group，这样就可以多一个编辑框了。</p>
<img src="/技术/Python/build_python_environment_with_sublime_text/main_UI.png" alt="main_UI.png" title="">
<p>至于左边的工作目录，只要每次打开的时候都选择打开文件就可以了，File-&gt;Open Folder，然后选择你的工作目录就可以了。</p>
<p>终于搭建好了一个舒心的Python工作环境，以后可以开开心心写Python了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;small&gt;&lt;em&gt;总字数：约3600字，阅读时间：约7分钟&lt;/em&gt;&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;自从学习了Python之后，一直想找一个好的Python IDE环境，但是一直没有找到心仪的。我认为，程序员一定要对自己好一点，每天面对的编程界面一定要赏心悦目，不然如何面对一天的工作。Pycharm的工作界面略显难看，换了各种主题都没有找到合适的，而且Pycharm实在有点大，很多功能用不上，却让运行变得很卡。也曾经使用过一段时间VS (visual studio 2015)，对于曾经的C++程序员而言，VS的用户界面还是让我觉得很舒心的，但是VS新接入python时间不长，出现的很多问题很难找到合适的解决方案。还用过Eclipse+pydev的方式，但是我在学习Java的时候就觉得Eclipse的界面真的不是一般的难看。最后我放弃了所有的IDE，用Sublime Text 3来编写python程序，然后直接内嵌一个编译器来实现查看编译结果。但是每次调试的方法都是用print各种变量的方式来看，效率低下。终于，我找到了一个合适的插件，能方便的调用PDB调试程序，现在写Python整个人都是开心的。&lt;/p&gt;
&lt;h4 id=&quot;Sublime-Text-3&quot;&gt;&lt;a href=&quot;#Sublime-Text-3&quot; class=&quot;headerlink&quot; title=&quot;Sublime Text 3&quot;&gt;&lt;/a&gt;Sublime Text 3&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://www.sublimetext.com/3&quot;&gt;ST3 (Sublime Text 3)&lt;/a&gt; 是一个跨平台的文本编辑器，以其丰富的快捷键和灵活的插件著称，使用起来相当的方便。而且我认为，ST3是我见过最漂亮的文本编辑器。这个编译器自带了很多的编程语言的高亮显示，C/C++，Python，Java，Matlab等等。在这个界面的吸引下，我决定转投ST3的旗下。&lt;/p&gt;
&lt;img src=&quot;/技术/Python/build_python_environment_with_sublime_text/main_UI.png&quot; alt=&quot;main_UI.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;可以看到，中间是主要的编程界面，左边是工作目录，右边上面是PDB的调试界面，右边下面是Python的交互式界面。将编程界面用来专心写程序，程序的编写过程中如果遇到什么语言方面或者库内容方面的问题，可以在右下角的交互式界面中进行查看。代码编写完之后，可以在右上角用PDB进行调试，而且在调试的时候也可以很方便的查看代码。并且可以根据工作目录来查看工程下其他的源码。在ST3中，其可以通过右键跳转到函数的定义之中，可以方便的查看函数内容。并在结合ST3中自带的各种快捷键，编码效率相当高。有兴趣的同学可以看看这份&lt;a href=&quot;https://docs.sublimetext.info/en/latest/index.html&quot;&gt;非官方教程&lt;/a&gt;，和它的&lt;a href=&quot;http://sublime-text.readthedocs.io/en/latest/getting_started/install.html&quot;&gt;中文版非官方教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;具体的安装方法在教程里面都有，可以在里面看，安装这个不是我要讲的主要内容，所以在这就不提了。遇到问题的话可以谷歌一下，基本上没有什么问题。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://arstead.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="python" scheme="https://arstead.github.io/categories/%E6%8A%80%E6%9C%AF/python/"/>
    
    
      <category term="技术" scheme="https://arstead.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>《异类-不一样的成功启示录》 马尔科姆·格拉德威尔 著</title>
    <link href="https://arstead.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Outliers_The_Story_of_Success/"/>
    <id>https://arstead.github.io/读书笔记/Outliers_The_Story_of_Success/</id>
    <published>2017-02-13T15:18:55.000Z</published>
    <updated>2017-03-24T04:41:49.296Z</updated>
    
    <content type="html"><![CDATA[<p><small><em>总字数：约6500字，阅读时间：约13分钟</em></small></p>
<blockquote>
<p>成功=机遇+努力+智力+环境</p>
</blockquote>
<p>这本书有点意思，我读了两遍。第一遍读的时候并没有读出他内在的逻辑和深度，只是单纯的将这本书看成是一本励志书籍来读，但是第二遍读的时候发现，这本书确实相当的有意思，整本书论证了一件事情，获得成功需要哪些条件？而答案，也就是这本书的核心观点，可以由本文的第一句话高度概括。</p>
<h4 id="机遇"><a href="#机遇" class="headerlink" title="机遇"></a>机遇</h4><p>本书中，格拉德威尔认为，机遇是让努力成为可能的前提。本书开篇就引用了《新约-马太福音》中的名言</p>
<blockquote>
<p>凡是有的，还要加给他，叫他有余。没有的，连他所有，也要夺过来。</p>
</blockquote>
<p>马太效应是一种强者越强，弱者越弱的反馈效应。本书从加拿大曲棍球联赛运动员奇特的出生月份分布入手，揭示了机遇对于成功影响方式。</p>
<a id="more"></a>
<p>格拉德威尔在统计了加拿大曲棍球联赛顶尖运动员的出生日期，发现大多数运动员出生于一年的头三个月，而越往后的月份人数越少。在分析了一系列原因之后，他发现，出现这种现象的原因是因为加拿大曲棍球联赛的注册时间是1月1日，而且要求注册时年满9岁。这就意味着，在一年中越早出生的人，到了可以注册的年龄时，将比一年中稍晚出生的人多出一段发育时间。对于青少年而言，半年的时间足以让一个人的体格发生很大的变化。在这种情况下，体格越好的人，在比赛中就越有优势，在训练中就越能得到教练的青睐，可以获得更多的训练机会和比赛机会。结合马太效应，强者最终保留在赛场上，而弱者将一步步被淘汰。</p>
<p>在调查了同样具有注册时间的英国足球联赛后，他发现了同样的出生月份分布情况。英国足球联赛的注册时间是9月1日。在英国顶级比赛中，出生于9月，10月，11月的运动员占据了绝大多数。这也进一步论证了他的观点。</p>
<p>值得一提的是，在深入挖掘了不同青少年在划分到不同等级的联赛之后，格拉德威尔发现，真正影响不同人最后结果的原因是训练时间的差异。</p>
<h4 id="努力"><a href="#努力" class="headerlink" title="努力"></a>努力</h4><p><strong>在成为一个行业里的专家，需要达到一万小时的训练时间</strong>。格拉德维尔在统计了一个艺术学院的小提琴班的所有学生，并对她们可能达到的成就进行了分成了能成为顶尖艺术家，能成为普通从业者和能成为艺术教师等三个组。他发现，三个组中的所有人，都差不多同一时间开始接触小提琴，并且前期的每日练琴时长都大同小异。只是到了12岁之后，才出现了不同的情况。对于被认为能成为顶尖艺术家组的人，在12岁以后，依旧保持着每日8个小时的训练时间，而对于被认为能成为艺术教师的人，每天的训练时间只有4个小时。在这种情况下，当大家都毕业的时候，被认为能成为顶尖艺术家的人已经达到了一万个小时的训练时间，而被认为能成为艺术教师的人只有四千个小时的训练时间。训练时间的差距使得人们在技能上出现了质的差距。</p>
<p>对于曲棍球运动员而言，在注册之后，由于起初所分配的联赛级别不同，所能参加的比赛场次也有很大差距。在这种情况下，被分到国家级联赛的青少年就相当于能成为顶尖艺术家的小提琴手，他们有大量的训练时间，有大量的上场机会。等到成年之后，他们就顺理成章的称为了行业内的佼佼者。</p>
<p>其次，本书对前微软总裁，前世界首富比尔·盖茨进行了分析。比尔·盖茨所在的中学，有基金会资助购买了一台电脑。在那时，电脑相当昂贵，普通人基本上不可能接触到电脑。比尔·盖茨接触到电脑后，被深深的吸引。每天都使用大量的时间在编程上。由于上机时长受限，他跟他当时的同学一起给一家软件公司编写程序，回报就是能获得上级时长。其后，他又发现华盛顿大学的机房可以申请使用，并且发现了其中在使用时长的一个漏洞，从而可以无限时使用电脑。在这种情况下，等到他开始编写MS-DOS系统的时候，他已经有了超过一万个小时的编程经验。</p>
<p>相同的例子还有甲壳虫乐队，其最开始也是一个默默无闻的小乐队，在德国的酒吧中演唱，但是其签约的公司给了他们大量的演出安排，并且会演唱各种形式的音乐，使得他们每天要演唱8到10个小时，而且可能在周末也没有休息时间。他们表示，一年中可能有两百多天都需要这样的长时间的演出。在这样的训练强度下，经过了4，5年的时间，他们一跃成为最为著名的乐队之一。</p>
<p>格拉德威尔表示，在大多数人获得成功时，都已经经过了一万个小时的训练，获得这种训练强度需要一定的机会，就像比尔·盖茨所在的学校恰好购入了一台计算机，并且在无法使用中学计算机时能有公司提供上机时长；甲壳虫乐队签约的公司能提供足够多的演出机会。上文提到的曲棍球的例子也是如此，在注册时被选入国家级联赛，从而带来了足够多的训练机会。</p>
<h4 id="智力"><a href="#智力" class="headerlink" title="智力"></a>智力</h4><p>智商是不是成功的要素之一？答案是肯定的。但是我们通常高估了智商的影响。这个世界上，并不是智力越高，就会越成功。</p>
<p>本书论证了斯坦福心理学家刘易斯·特曼在一战后的研究。特曼在发现一个贫民区长大的小孩亨利·考埃尔拥有超群的智力之后，开始不断寻找世界上智力超群的人。他在小学中进行智力测试，并将智商在140至200之间得学生挑选出来作为研究样本，而这些人也被称之为“特曼人”。他详细记录了这些人的成长经历及杰出成就。他的研究发现，在有这些人参加的各种比赛或者活动中，都能在获奖名单中看到他们的名字。所以特曼认为高智商是成功的关键因素，“对于个体而言，没有什么比他的智商更重要”。</p>
<p>但是，格拉德威尔列举出诺贝尔获奖者所属学校的名单发现，这些获奖者中，不仅仅只有哈佛大学，麻省理工大学这样的顶尖院校，也有迪堡大学，圣十字学院这样被认为不是那么好的学校。而且在诺贝尔获得者中，威廉·肖克利和路易斯·阿尔瓦雷诺在小学时并没有通过特曼的智力测试。这从一个侧面反映出了并不是高智商一定就会能获得更好的成就。</p>
<p>本书在智商对成功的影响这个方面，给出的主要观点是<strong>智商能达到正常人即可，超过正常水平之后对成功的影响程度将变小</strong>。</p>
<p>本书中通过两个对比人物来表明智力对于成功的影响。一个是克里斯托弗·兰根，另一个是著名的物理学家罗伯特·奥本海默。他们俩都属于智力超群的人，克里斯托弗·兰根的智力达到180，参加了美国综艺节目《以一敌百》（一个由一人向一百个人发起答题挑战的节目）并获得了丰厚的奖金。罗伯特·奥本海默是原子弹之父，是曼哈顿计划的带头人。</p>
<p>但从智力上来说，克里斯托弗·兰根的智力要高于罗伯特·奥本海默，但是奥本海默成为了世界知名的人物，而兰根却无人知晓。格拉德威尔深入分析了这两个人的生活情况，得出了一个结论：<strong>在实际环境当中，对于智商达到正常水平的人，“实用智商”（处理社会中出现各种问题的能力，受社会阅历的影响）显得更为重要</strong>。</p>
<p>兰根出生于一个贫困家庭，母亲改嫁过多次。其继父喜欢酗酒，经常不回家，而且曾使用兔笼关押他们。其弟弟表示当时没有任何一所学校认为兰根有过人的智慧。兰根中学毕业之后申请了两所高校的全额奖学金。他在里德学院学习时，由于母亲没有按时提交父母经济状况说明，导致其失去了第二年的奖学金。他埋怨学校没有任何的通知。在期末考试后，成绩只有F的他离开了里德学院。一年半后，其进入蒙大拿州立大学学习。在一个冬天，因为学校距离小镇有13英里，而他的汽车动力系统出问题了，所以他希望调整他的课程到下午，这样中午就可以搭乘小镇农场工人的顺风车上学。但是他的导师看到了他在里德学院的生活状况之后，认为他应当为了学习做出一定的牺牲，并且驳回了他的请求。在这样艰苦的环境下，他最后认为即使没有受过高等教育也可以完成很多事情，最终离开了大学。格拉德威尔分析这两次学习经历是他人生中的转折点，他认为兰根本可以获得博士学位，并在大学任职。但是其拙略的社交能力，使得其无法融入大学生活，使其认为这两所学校根本就是一个结构庞大，体制僵硬的官僚机构。而这一切的根源在与其幼年时的经历。家庭生活使得其没有与外界沟通的能力，对于调整课程时间这样在大学生中经常出现的事情都无法做到很好的沟通。</p>
<p>而相对而言，奥本海默是一个完全相反的例子。奥本海默也是一个智力超群的人，在三岁时已经可以完成各种实验，五岁时就开始学习化学和物理。奥本海默在进入剑桥大学攻读博士学位期间，由于其天赋在于理论物理而其导师却让其做一些繁琐的物理实验，导致其情绪及其不稳定。最后他企图用实验室中的化学试剂毒死其导师。由于其导师发现了这个事情而没有出现伤亡。他在被叫到学校办公室后，进过了长时间的漫谈，最终的处罚结果仅仅只是留校察看。同样是在大学时期面临危机，而奥本海默却有办法为自己的谋杀辩护。而兰根却连调整课程时间都无法完成。</p>
<p>这种能力的不同被心理学家罗伯特·斯滕伯格称之为“实用智商”，它指的是<strong>让你正确认识自身处境，并且达到自己目的的能力</strong>。这种能力与一般的智商（分析推理智商）并没有直接的联系。“实用智商”主要源自于家庭生活环境，与幼年的成长有很大的关系，相当于是一种社会经验。兰根幼年时在家庭生活中出现的虐待，使其愤恨权威 并且喜欢独来独往，而奥本海默从小就被鼓励尝试。奥本海默幼年时对岩石的兴趣，使其在12岁时就尝试与当地的地质学家交流，并且受到邀请到纽约矿物学俱乐部发表演说。面对全是成年人的地质学家和岩石爱好者，奥本海默虽然有些害羞、笨拙，但是其依旧完成了演讲，并获得了热烈的掌声。这样的社会经历，使他学习到了如何与人交流才能达到自己的目的，而这就是“实用智商”。</p>
<p>回过头来看上文提到的“特曼人”。在特曼的资料中，所有760个“特曼人”长大后根据表现情况被分为了三个不同的小组。表现突出的150人小组中90%从大学毕业，其中98%人有研究生学历。而表现最差的150人小组中，有三分之一人有大学辍学经历，四分之一人只有高中学历。是什么原因导致了如此大的差距，特曼从个中方面进行了分析：身体和精神状态，业余爱好和职业，成长过程中的智商变化。但是都没有很好的解释这个现象。格拉德威尔指出，特曼缺少了对家庭背景的分析。他发现，在表现突出的组中，绝大部分人来自中产阶级或者上层家庭。而表现最差的组中，几乎三分之一的人，父母八年级之前就辍学了。</p>
<p>格拉德威尔表示，这些智商超群的天才<strong>缺少的是一种健康的成长环境，没有养成正确面对世界的态度</strong>。这是导致他们最终走向没落的原因。</p>
<h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><p>与前文中学习环境不同，这里所指的环境是运用环境，也就是社会需求。事实上，环境才是最为依靠运气的因素。</p>
<p>格拉德威尔运用大量的实例来表达环境的重要性。他在列举了《福布斯》人类历史上最富有的75人发现，75个人中，有14个美国人出生在19世纪30年代到40年代。事实上，在人类历史长河中，这个比例是相当可观的。而出现这种情况的主要原因在于，19世纪60年代到70年代，正是美国历史上经济发生最大变革的时代。而这个时候，出生于19世纪30年代到40年代的里正好是出于20到30岁左右，能把握住这样的机遇。如果你出生在40年代之后，会由于年龄太小和错失机会。如果出生在20年代，则会因为思维老化而赶不上时代潮流。所以，30年代到40年代的这10年出生的人，才能赶上美国的黄金时代，并且抓住这样的机遇。</p>
<p>同样，我们再来回忆一下前面提到的比尔·盖茨，计算机发展的辉煌时代在于20世纪70年代。准确的说是1975年《大众电子》杂志报道的世界上第一台微机Altair 8800。那么，如果你从事的是计算机行业，如果在这个时候你的年龄比较高了，你很有可能进入IBM这样大型的企业工作，而不会想着去改变世界。同样，如果你的年级很小，那么你并不可能在这个时代中有所作为。所以对于这个黄金时期来说，你的出生年月最好是在1955年左右。看看比尔·盖茨，出生于1955年10月28日，似乎就是为了这个时代而生的。</p>
<p><strong>环境的需求让经过一万小时的训练有了用武之地，而这也是让人成功的关键一步</strong>.</p>
<h4 id="根源"><a href="#根源" class="headerlink" title="根源"></a>根源</h4><p>上文中提到了那么多的成功的影响因素，都是外显的特性，是个人或者环境所表现出来的要求。但是格拉德威尔似乎不满足于仅仅只看到成功所需求的特性，他还更深入的了解到到底是什么因素影响到了不同人之间表现出不同特性的原因。所以，其深入分析了几个事例，发现了留存于传统文化中的影响。</p>
<p>在分析了肯塔基州中哈兰小镇中的两个创始家族的矛盾缘由，作者发现，传统文化的影响使得人们的处事方式大相径庭。在哈兰小镇中，霍华德家族和特纳家族的纷争，导致了两大家族多次发生枪战，并出现了大规模的伤亡。事实上，在深入调查了相关事件后，格拉德威尔发现，在19世纪80年代，整个肯塔基州出现过大量的争斗事件，谋杀案件的起诉书有上千份。而这些冲突的根本原因来自于这个地区的“荣誉文化”。</p>
<p>在高原地区，人们赖以生存的主要产业是畜牧业。相较于农民由于耕作所形成的合作文化，牧民显得相当封闭。牧民们经常需要担忧自己的动物丢失，在不断受到威胁后，他们必须要表现出进攻性，他们需要通过言行来证明自己不是弱者。他们接受来自外界的任何挑战，他们会奋起反抗任何一种轻视。而这种生活方式使得他们慢慢形成了一种荣誉文化，他们的大多数争执不是为了个人利益，而是为了荣誉，为了自己的荣誉战斗。事实上，在20世纪90年代，密歇根大学的两位心理学家多夫·科恩和理查德·尼斯贝特就进行过一项荣誉文化的实验。他通过对比发现，美国南部的年轻人，在面对被骂“混蛋”这样的侮辱之后，表现出了比北方人更高程度的愤怒情况。他们发现，决定他们反应程度的不是感情的稳定性或者身体的强壮程度，而是你来自哪里。北方人主要用娱乐的方式处理突发事件，所以在面对问题是，他们通常一笑而过，用这种方式化解愤怒。而南方人却显得十分愤怒。事实上，<strong>这些人已经摆脱了祖先们的生活方式，但是这种荣誉文化的依旧流传在他们的内心，一代又一代的被传承下来</strong>。</p>
<p>同样，我们可以对比分析一下亚洲文化和欧洲文化。在中国，农业耕作是主要的生产方式，固定租金的租地制度使得田地中多余的产出均归农民所有。这使得农民们养成了勤劳致富的思维方式，由于每个人的耕种面积少，他们会精确计算每一个步骤的时间点，耕地，插秧，施肥，除虫，这些操作保证了每一分土地都能达到最大的产出。而在冬季时分，农民们也不会闲着，编织竹篮，制作大酱。在中国，农民的年工作时间多达3000多个小时。“一分耕耘，一分收获”，中国的传统谚语也体现出了中国人的生活哲学。而与欧洲文化不同，欧洲采取的则是雇佣制度，农民的收入来自于贵族的报酬，而土地的收成并不会对他们的财富产生多大的影响。在这种情况下，农民并不会起早贪黑的去田里工作。而且，由于耕地面积相对较广，他们更推崇于“机械化作业”，所以在他们的思维方式中，要提高产量的主要方式则是耕种耕种更多的土地，而他们的年工作时间在1000小时左右。。相对于这种情况而言，他们的后代更加推崇一种休闲的生活。俄国的谚语“没有老天的恩慈，地理哪来的粮食”也是他们在这种制度下面体现出来的宿命论思想和内心的悲观主义。</p>
<p>在这样的传统文化影响之下，亚洲人能表现出更加勤奋的工作状态。在学校中，他们能会坚持更加长的学习时间，他们能比别人付出更多的努力。而这些辛勤的劳动也是亚洲人收益颇丰。事实上，在对比国际数学竞赛的比赛结果就能看的出来，亚洲人能表现出更优异的成绩，这不是因为他们的智商有多高，仅仅只是因为他们能坚持做更多的题。宾夕法尼亚大学的教育学者俄林·波发现，让参加TIMSS竞赛（国际数学和科学测评趋势）的青少年填写一份冗长的问卷，这份问卷仅包含父母教育程度，对朋友的描述等无意义的问题。而这份问卷的成绩由答题数量来决定。他惊奇的发现，问卷排名与数学竞赛的结果几乎完全一样。</p>
<p>在传统文化的影响下，我们表现出不同的工作态度，生活态度。而这些态度，在后续指导这我们不断前行。但是，群体的影响下，个体的特性依旧可以得意保留。归根结底，<strong>影响成功最关键的因素在与努力程度</strong>。智力能达到正常即可。传统文化和机遇都只是让人们能更加容易实现达到专业所要求的努力程度。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>格拉德威尔的这本书里面蕴含了大量的历史实例，深入分析了各种影响因素在成功中的作用。大量的故事描述使得阅读过程轻松愉悦。但是，故事描述过于分散，使得很难抓住书中的逻辑点，难以总结作者想要表述的观点。总体而言，是一本值得当床前读物阅读的书籍。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;small&gt;&lt;em&gt;总字数：约6500字，阅读时间：约13分钟&lt;/em&gt;&lt;/small&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;成功=机遇+努力+智力+环境&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这本书有点意思，我读了两遍。第一遍读的时候并没有读出他内在的逻辑和深度，只是单纯的将这本书看成是一本励志书籍来读，但是第二遍读的时候发现，这本书确实相当的有意思，整本书论证了一件事情，获得成功需要哪些条件？而答案，也就是这本书的核心观点，可以由本文的第一句话高度概括。&lt;/p&gt;
&lt;h4 id=&quot;机遇&quot;&gt;&lt;a href=&quot;#机遇&quot; class=&quot;headerlink&quot; title=&quot;机遇&quot;&gt;&lt;/a&gt;机遇&lt;/h4&gt;&lt;p&gt;本书中，格拉德威尔认为，机遇是让努力成为可能的前提。本书开篇就引用了《新约-马太福音》中的名言&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;凡是有的，还要加给他，叫他有余。没有的，连他所有，也要夺过来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;马太效应是一种强者越强，弱者越弱的反馈效应。本书从加拿大曲棍球联赛运动员奇特的出生月份分布入手，揭示了机遇对于成功影响方式。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://arstead.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://arstead.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>在Hexo+NexT中添加algolia search</title>
    <link href="https://arstead.github.io/%E6%8A%80%E6%9C%AF/Hexo/How_to_add_algolia_into_hexo/"/>
    <id>https://arstead.github.io/技术/Hexo/How_to_add_algolia_into_hexo/</id>
    <published>2017-01-29T12:02:55.000Z</published>
    <updated>2017-03-28T15:12:13.125Z</updated>
    
    <content type="html"><![CDATA[<p><small><em>总字数：约3000字，阅读时间：约5分钟</em></small></p>
<p>在Hexo里面文章多了以后就会出现难以查找内容的问题，所以就需要一个站内搜索的功能。我大致看了一下NexT上支持的集中站内搜索引擎，<a href="https://swiftype.com/" target="_blank" rel="external">Swiftype</a>因为注册需要一个企业邮箱，而本人学生党并没有企业邮箱。<a href="http://tinysou.com/" target="_blank" rel="external">微搜索</a>好像主页崩了，一直登陆不上去。像百度，google这样的本地搜索UI设计实在是不堪入目。然后就选择了algolia。好在NexT 5.1以上的版本已经支持了algolia搜索，接入也比较的方便。</p>
<p>这是一个法国初创公司做的，致力于在毫秒级时间内完成内容搜索，具体的细节可以上官方网站 <a href="https://www.algolia.com/" target="_blank" rel="external">algolia</a> 。搜索呈现像下面这样:</p>
<img src="/技术/Hexo/How_to_add_algolia_into_hexo/result.png" alt="result.png" title="">
<a id="more"></a>
<h4 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h4><ol>
<li><p>首先，上 <a href="https://www.algolia.com/" target="_blank" rel="external">algolia</a> 上注册一个账号，免费注册的账号可以试用14天，这期间所有的高级功能均可以使用。过了这个期限之后，只有部分功能可以使用，免费账户总共有10,000条记录，每个月有100,000的可操作数，对于一般用户应该是够用了。</p>
<p> 注册了账户之后，页面如下图所示，点击NEW INDEX。需要输入一个index name， 注意这个名字最好只包含字母，数字和下划线(_)，因为后端用js调用数据的时候需要用到这个index name，所以如果这个字符串里面出现了一些跟js语法像冲突的符号很有可能识别不了。</p>
 <img src="/技术/Hexo/How_to_add_algolia_into_hexo/algolia.png" alt="algolia.png" title="">
</li>
<li><p>完成之后，点击左边那个像钥匙一样的图标，查看自己的API Keys。注意Admin API Key是私密保存的，可以点击右边的小图标进行复制。</p>
 <img src="/技术/Hexo/How_to_add_algolia_into_hexo/key.png" alt="key.png" title="">
</li>
<li><p>进入站点配置文件_config.yml，在后面加入下面这些内容，其中将具体的值换成自己的Keys，注:不需要引号。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># website search</div><div class="line">## algolia</div><div class="line">algolia:</div><div class="line">  applicationID: &apos;your_Application_ID&apos;</div><div class="line">  apiKey: &apos;your_Search-Only_API_Key&apos;</div><div class="line">  adminApiKey: &apos;your_Admin_API_Key&apos;</div><div class="line">  indexName: &apos;your_Index_Name&apos;</div><div class="line">  chunkSize: 5000</div></pre></td></tr></table></figure>
</li>
<li><p>进入git bash，在根目录下安装algolia。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-algolia --save</div></pre></td></tr></table></figure>
</li>
<li><p>在hexo目录下提交站点。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo algolia #等价于hexo a</div></pre></td></tr></table></figure>
<p> 产生的结果大致如下:</p>
 <img src="/技术/Hexo/How_to_add_algolia_into_hexo/hexo_a_result.png" alt="hexo_a_result.png" title="">
<p> 然后我们可以进入algolia的用户中心看一下是否内容已经提交上了。看一下红框中是否有内容。</p>
 <img src="/技术/Hexo/How_to_add_algolia_into_hexo/algolia_index.png" alt="algolia_index.png" title="">
<p> 有时候可能发现没有上传到数据，在git bash中出现下面这样的显示，这个时候只需要先清理一下缓存，执行一下hexo clean，然后再执行hexo a提交站点即可。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">INFO  [Algolia] Identified 0 posts to index.</div></pre></td></tr></table></figure>
<p> 这里要特别注意一下是否存在path字段，如果没有这个字段的话，搜索的时候会因为js无法检索到内容，而直接填入’undefine’，从而出现404异常。</p>
 <img src="/技术/Hexo/How_to_add_algolia_into_hexo/undefine.png" alt="undefine.png" title="">
<p> 这个时候我们要进入.\hexo\node_modules\hexo-algolia\lib\command.js文件，添加path字段进storedPost变量中，</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var storedPost = _.pick(data, [&apos;title&apos;, &apos;date&apos;, &apos;slug&apos;, &apos;path&apos;, &apos;content&apos;, &apos;excerpt&apos;, &apos;permalink&apos;]);</div></pre></td></tr></table></figure>
<p> 然后重新提交站点即可。</p>
</li>
<li><p>最后进入主题配置文件，找到algolia_search选项，将enable字段值改为true。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># Algolia Search</div><div class="line">algolia_search:</div><div class="line">  enable: true</div><div class="line">  hits:</div><div class="line">    per_page: 10</div><div class="line">  labels:</div><div class="line">    input_placeholder: Search for Posts</div><div class="line">    hits_empty: &quot;We didn&apos;t find any results for the search: $&#123;query&#125;&quot;</div><div class="line">    hits_stats: &quot;$&#123;hits&#125; results found in $&#123;time&#125; ms&quot;</div></pre></td></tr></table></figure>
<p> 最后重新生产站点，重新部署就完成了。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo g -d</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><h5 id="页面空白"><a href="#页面空白" class="headerlink" title="页面空白"></a>页面空白</h5><p>在安装的时候出现了文章内容加载不出来，但是查看源码的时候HTML是完整的，而且对应位置的链接也可以，如下图一样：</p>
<img src="/技术/Hexo/How_to_add_algolia_into_hexo/black.png" alt="black.png" title="">
<p>查看加载情况的时候发现js调用异常，发现是因为index name里面包含了引号，导致algolia后端的js出现异常，所以页面加载出现问题。这个时候只需要修改一下index name就可以了。</p>
<h5 id="搜索后无法正确跳转"><a href="#搜索后无法正确跳转" class="headerlink" title="搜索后无法正确跳转"></a>搜索后无法正确跳转</h5><p>搜索后出现无法正确跳转的原因是algolia没有获取path字段，所以最后的跳转地址没有正确填充，有可能会出现点击没有反应，也有可能像上文中提到的出现404异常，这个时候只需要按上文所说，在.\hexo\node_modules\hexo-algolia\lib\command.js文件里，添加path字段到storedPost变量中即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var storedPost = _.pick(data, [&apos;title&apos;, &apos;date&apos;, &apos;slug&apos;, &apos;path&apos;, &apos;content&apos;, &apos;excerpt&apos;, &apos;permalink&apos;]);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;small&gt;&lt;em&gt;总字数：约3000字，阅读时间：约5分钟&lt;/em&gt;&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;在Hexo里面文章多了以后就会出现难以查找内容的问题，所以就需要一个站内搜索的功能。我大致看了一下NexT上支持的集中站内搜索引擎，&lt;a href=&quot;https://swiftype.com/&quot;&gt;Swiftype&lt;/a&gt;因为注册需要一个企业邮箱，而本人学生党并没有企业邮箱。&lt;a href=&quot;http://tinysou.com/&quot;&gt;微搜索&lt;/a&gt;好像主页崩了，一直登陆不上去。像百度，google这样的本地搜索UI设计实在是不堪入目。然后就选择了algolia。好在NexT 5.1以上的版本已经支持了algolia搜索，接入也比较的方便。&lt;/p&gt;
&lt;p&gt;这是一个法国初创公司做的，致力于在毫秒级时间内完成内容搜索，具体的细节可以上官方网站 &lt;a href=&quot;https://www.algolia.com/&quot;&gt;algolia&lt;/a&gt; 。搜索呈现像下面这样:&lt;/p&gt;
&lt;img src=&quot;/技术/Hexo/How_to_add_algolia_into_hexo/result.png&quot; alt=&quot;result.png&quot; title=&quot;&quot;&gt;
    
    </summary>
    
      <category term="技术" scheme="https://arstead.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Hexo" scheme="https://arstead.github.io/categories/%E6%8A%80%E6%9C%AF/Hexo/"/>
    
    
      <category term="技术" scheme="https://arstead.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>在Hexo+NexT中添加标签和分类</title>
    <link href="https://arstead.github.io/%E6%8A%80%E6%9C%AF/Hexo/How_to_add_tags_page/"/>
    <id>https://arstead.github.io/技术/Hexo/How_to_add_tags_page/</id>
    <published>2017-01-28T10:02:55.000Z</published>
    <updated>2017-03-24T04:42:58.138Z</updated>
    
    <content type="html"><![CDATA[<p><small><em>总字数：约1300字，阅读时间：约3分钟</em></small></p>
<h3 id="添加标签和分类"><a href="#添加标签和分类" class="headerlink" title="添加标签和分类"></a>添加标签和分类</h3><p>在Hexo中，有两种管理的方式，一种是使用分类的方式，这是一种有层次的分类方式，适用于大类别下套小类别的分类方式，例如：编程语言-python等。而还有一种是使用标签的方式，这种方式适用于同一级别的类别分类方式，例如：小说，论文等。<br>对应于具体的文章，可以在Front-matter中进行设定，例如：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">title: 标签</div><div class="line">tages: </div><div class="line"> -小说</div><div class="line"> -论文</div><div class="line">---</div><div class="line"></div><div class="line">---</div><div class="line">title: 分类</div><div class="line">categories: </div><div class="line"> -编程语言</div><div class="line"> -python</div><div class="line">---</div></pre></td></tr></table></figure>
<p>在这种情况下，Hexo将会自动的将每一篇文章进行归档。</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>在很多时候我们点击标签页和分类页查看具体情况的时候会出现一些问题。这里描述一下常见的两种情况。</p>
<h4 id="文件路径包含中文"><a href="#文件路径包含中文" class="headerlink" title="文件路径包含中文"></a>文件路径包含中文</h4><p>在很多时候会报下面这种错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">TypeError: The header content contains invalid characters</div></pre></td></tr></table></figure>
<p>出现这种问题的主要原因是路径中出现了中文，只需要将分类的路径改成英文即可。</p>
<h4 id="没有生产标签页和分类页"><a href="#没有生产标签页和分类页" class="headerlink" title="没有生产标签页和分类页"></a>没有生产标签页和分类页</h4><p>有时候还会出现下面这种问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cannot get /tags/</div><div class="line">cannot get /categories/</div></pre></td></tr></table></figure>
<p>出现这种问题是因为配置路径和实际路径不对。配置路径在主题文件夹(.\hexo\themes\next)中的_config.yml文件里面。找到下面这样的描述，例如我使用tags表示标签页。需要检查一下是否在.\hexo\source文件夹中存在tags文件夹，如果不存在则需要创建tags标签页。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">menu:</div><div class="line">  home: /</div><div class="line">  categories: /categories</div><div class="line">  tags: /tags</div><div class="line">  about: /about</div><div class="line">  #archives: /archives</div><div class="line">  #sitemap: /sitemap.xml</div><div class="line">  #commonweal: /404.html</div></pre></td></tr></table></figure>
<p>创建标签页的方法是使用hexo中的指令来添加，以tags为例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo new page tags</div></pre></td></tr></table></figure>
<p>执行这条指令之后，在.\hexo\source文件夹下会新增一个tags文件夹，里面有一个index.md。打开来之后里面只有title和date属性，我们需要添加一个type属性，修改成下面这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">title: tags</div><div class="line">date: 2017-01-28 01:55:09 #时间随意</div><div class="line">type: tags</div><div class="line">---</div></pre></td></tr></table></figure>
<p>分类页的情况一样，需要把type属性改成categories</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">title: categories</div><div class="line">date: 2017-01-28 02:15:09 #时间随意</div><div class="line">type: categories</div><div class="line">---</div></pre></td></tr></table></figure>
<p>完成修改之后重新生成部署即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;small&gt;&lt;em&gt;总字数：约1300字，阅读时间：约3分钟&lt;/em&gt;&lt;/small&gt;&lt;/p&gt;
&lt;h3 id=&quot;添加标签和分类&quot;&gt;&lt;a href=&quot;#添加标签和分类&quot; class=&quot;headerlink&quot; title=&quot;添加标签和分类&quot;&gt;&lt;/a&gt;添加标签和分类&lt;/h3&gt;&lt;p&gt;在Hexo中，有两种管理的方式，一种是使用分类的方式，这是一种有层次的分类方式，适用于大类别下套小类别的分类方式，例如：编程语言-python等。而还有一种是使用标签的方式，这种方式适用于同一级别的类别分类方式，例如：小说，论文等。&lt;br&gt;对应于具体的文章，可以在Front-matter中进行设定，例如：&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://arstead.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Hexo" scheme="https://arstead.github.io/categories/%E6%8A%80%E6%9C%AF/Hexo/"/>
    
    
      <category term="技术" scheme="https://arstead.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>一个人的能力(二)</title>
    <link href="https://arstead.github.io/%E5%B0%8F%E8%AF%B4/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E8%83%BD%E5%8A%9B/(%E4%BA%8C)/"/>
    <id>https://arstead.github.io/小说/一个人的能力/(二)/</id>
    <published>2017-01-27T11:06:55.000Z</published>
    <updated>2017-03-05T13:54:45.739Z</updated>
    
    <content type="html"><![CDATA[<p><small><em>总字数：1493字，阅读时间：约3分钟</em></small></p>
<p>上午最后一节课总是显得那么漫长，特别还是数学课的时候，大家一边将老师写在黑板上的公式抄到笔记本之中，一边偷瞄墙上挂的时钟。等着秒钟一步一步的向前走，走完一圈又回到原点，好像时间又回到了最初的原点一般，停滞不前。终于，下课铃声响起，而老师上课的内容也基本讲完，高中的老师总是喜欢来下课之后再多占用一点时间，而刘老师也是一样，“我把作业布置完咱们就下课，今天做完习题册圆锥曲线最后的双曲线部分，每一个人最好都去推导一下三种圆锥曲线的表达式是怎么来的，有助于你们对这部分内容的理解，下课”。靠门边的同学像是听到了一声哨响一般，直接提着包冲出了教室。而李情旭，依旧默默的坐在那，回顾着刚刚上课记得笔记。“你怎么知道这节课老师心情不好的呀？”胡梦边收拾书包，边跟他闲扯。“因为我有超能力。”李情旭没有回头，一本正经的说出这句话。“你再扯，我吃饭去啦，拜拜”胡梦认为他在开玩笑，就打算去吃饭了。“拜”李情旭看着胡梦的背影默默的离开。</p>
<a id="more"></a>
<p>李情旭从出生开始，眼中的世界就和别人的不太相同。他看到的每一个人，头上都有一个小光点，闪烁着不同的光芒。他父母也带他去医院查过，但是并没有查出什么问题来。想着这件事并不会影响正常生活，所以大家也都没有再深究。而好奇心驱使着李情旭想探明这个光点究竟是什么，而不同的色彩又代表着什么。他开始观察每一个人头上的光点，渐渐发现当人们面带笑容时，头上的光点往往散发出黄色的光芒，而当人们脸上带有愁容的时候，头上的光芒往往是蓝色的。此刻，他意识到，这些光芒代表的是每一个人的内心情绪。而刘老师进门的时候，她的小光点散发着让人警觉的红色，这表示愤怒。</p>
<p>看了看墙上的时钟，距离放学已经过去半个小时了，这个时候他也该准备去吃饭了。他起身收拾东西，发现坐在后面的欧阳时还在那里看书，头顶上泛着深邃的蓝光。蓝色的光线在寂静的教室中显得格外的耀眼，空气中似乎都能感受出他的忧伤。李情旭看了看欧阳时，发现他目光呆滞，书中的文字并没有进入他的脑海。“欧阳时，你还不走呀？”李情旭决定跟他聊一下。“啊，等会就走。”欧阳时惊的一下抬起头，似乎才回过神来。“时间也不早了，一块去吃饭吧”，听到这句话，欧阳时才想起来看看时间，发现已经过了半个多小时了。“都这么晚啦，我不吃饭了”欧阳时把目光重新转向了书本。“大中午不吃饭下午哪有力气上课啊，现在也不算太晚，汤粉应该还有，走吧。”李情旭一把把他的书抽出来，放到自己桌上。欧阳时看到这种情况，感觉也不好再拒绝了，就只能勉强答应了他，“那走吧”。</p>
<p>午后的食堂已经不那么拥挤，他们各自买了一份汤粉，在食堂一个偏僻的角落坐下。这个位置是李情旭找的，他知道欧阳时现在心情很差，估计是什么不太容易说出口的事，所以找了一个偏僻的地方，这样才能更好的跟他谈心。“我看你刚刚魂不守舍的，有心事啊？”李情旭也比较直接，似乎并不打算拐弯抹角。“没有啊，应该是上课上的累了”欧阳时用筷子拨弄着自己碗里的面，似乎并不打算吃。“还没有心事，你的表情都写在脸上了，别憋着，说出来就好了，是不是看上哪个妹子不好意思说呀”李情旭看着他头上的蓝光，希望通过一句玩笑话转变一下气氛。“没，我也没资本看上别人呀”欧阳时看了看李情旭，似乎想说点什么，却又不知道该如何开口。“那你咋啦，没事，说出来就会好受了，而且我不跟别人说的”李情旭继续用语言来缓释他的心理防线，心中的事不愿意说无外乎就是怕别人知道，其实每个人都知道，倾诉是最好的释压的方式；只是，我们缺少一个能信任的倾听者。欧阳时看了看他眼中的班长，他第一次感受到有人如此关心自己。“我，家里出了点事。”</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;small&gt;&lt;em&gt;总字数：1493字，阅读时间：约3分钟&lt;/em&gt;&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;上午最后一节课总是显得那么漫长，特别还是数学课的时候，大家一边将老师写在黑板上的公式抄到笔记本之中，一边偷瞄墙上挂的时钟。等着秒钟一步一步的向前走，走完一圈又回到原点，好像时间又回到了最初的原点一般，停滞不前。终于，下课铃声响起，而老师上课的内容也基本讲完，高中的老师总是喜欢来下课之后再多占用一点时间，而刘老师也是一样，“我把作业布置完咱们就下课，今天做完习题册圆锥曲线最后的双曲线部分，每一个人最好都去推导一下三种圆锥曲线的表达式是怎么来的，有助于你们对这部分内容的理解，下课”。靠门边的同学像是听到了一声哨响一般，直接提着包冲出了教室。而李情旭，依旧默默的坐在那，回顾着刚刚上课记得笔记。“你怎么知道这节课老师心情不好的呀？”胡梦边收拾书包，边跟他闲扯。“因为我有超能力。”李情旭没有回头，一本正经的说出这句话。“你再扯，我吃饭去啦，拜拜”胡梦认为他在开玩笑，就打算去吃饭了。“拜”李情旭看着胡梦的背影默默的离开。&lt;/p&gt;
    
    </summary>
    
      <category term="小说" scheme="https://arstead.github.io/categories/%E5%B0%8F%E8%AF%B4/"/>
    
      <category term="一个人的能力" scheme="https://arstead.github.io/categories/%E5%B0%8F%E8%AF%B4/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E8%83%BD%E5%8A%9B/"/>
    
    
      <category term="小说" scheme="https://arstead.github.io/tags/%E5%B0%8F%E8%AF%B4/"/>
    
  </entry>
  
  <entry>
    <title>一个人的能力(一)</title>
    <link href="https://arstead.github.io/%E5%B0%8F%E8%AF%B4/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E8%83%BD%E5%8A%9B/(%E4%B8%80)/"/>
    <id>https://arstead.github.io/小说/一个人的能力/(一)/</id>
    <published>2017-01-27T10:51:55.000Z</published>
    <updated>2017-03-05T13:54:36.659Z</updated>
    
    <content type="html"><![CDATA[<p><small><em>总字数：1890字，阅读时间：约4分钟</em></small></p>
<p>老师伴着上课的曲子进门，班长李情旭看了一眼老师，扭头对同桌胡梦说：“这节课别睡觉了，刘老师心情很不好”。老师走上讲台，把考试卷子放在讲台桌子上，把U盘插在电脑上，像往常一样， 准备把上课的课件拷到电脑上。《土耳其进行曲》还在耳边回荡，也不清楚这所学校为什么要用这个曲子作为上课的铃声。估计是它的节奏比较欢快，能让人产生一种愉悦的心情以面对接下来四十五分钟的枯燥。老师还在操作着电脑，课间喧闹的气氛还没有消散，大家都七嘴八舌的讨论着。胡梦抬了抬头，看了看老师，像往常一样，没有任何的变化。胡梦又把头低了下来，枕在自己的手上。嘟囔了一句:“别闹”。李情旭也没有再理睡梦中的同桌，把目光转向投影出来的电脑画面。</p>
<a id="more"></a>
<p>这个班级的座位与大多数中学相同，每两排座位靠拢成一个大排，一共四大排，每个大排中间留出够一个人正常通行的空隙。而投影的位置在靠近窗户的位置，大概在第三大排的前方偏左。他们俩的位置在第三排的第二行。李情旭坐在左边，胡梦在右边。刘老师则在胡梦旁边过道的正前方。</p>
<p>这位老师姓刘，全名叫刘蕊，是一位年轻有为的女老师，不到三十岁就已经评上了国家特级教师，讲的是数学课，教学主张因材施教，在她的心中，每一个人都有其所能适应的教学方式，有些人给一些压力，才能将心思放在学习上，有一些人需要鼓励，才能进步，给压力反倒会让他们手足无措。还有一些人自我约束能力强，自己能把控好自己，约束过多了反倒会产生叛逆心理。李情旭属于第一种人，而胡梦则是第二种。在胡梦眼中，刘老师是一个和蔼可亲的人，经常找自己谈心，所以她的课 是胡梦最放松的课。</p>
<p>投影里显示着老师的操作，与往常不同的是，这次刘老师除了从U盘里拷贝了一个课件文档以外，还拷贝了一份表格文档。他将表格文档打开，每个人的学号，姓名，每道题的得分赫然投影到幕布之上。他抬起头，把两只手放在桌子上，静静的看着下面的同学。大家还在喧闹着，慢慢的，一些同学注意到了老师的举动，逐渐降低了自己的音量。但是，教室里依旧存在着细声细语。似乎总有那么一些人，无法控制住自己，总想把自己心里的八卦说出来。第二排第二行的高忆侧了下头，低声对着同桌柳知说：“昨天她的鬓发上就缠着那个线头，今天还在那，她昨天晚上一定没有洗头”。柳知一脸诧异的看着她：“这你都记得，你每天都在看些什么啊”。“你们什么时候停下来，我什么时候开始上课。”说完这话，刘老师坐了下来，静静的看着每一个人。大家看着讲台上表情严肃的老师，都知道情况不对。教室一时间变得十分寂静，没有任何的声响，电扇的声音在头顶上盘旋。</p>
<p>“你们怎么不讲了，继续讲呀”带着挑衅的语气，她的这句话划破了死一般的寂静。如果说刚才的沉默让每一个人都神情紧张，那么现在，每一个人已经开始畏惧。大家都低下了头，生怕与老师有过多的眼神接触。“你们看看你们的成绩”，刘老师抬起了手，不停的点着投影在幕布上的表格。大家都抬起了头，努力的寻找自己的名字，看看自己处在一个什么样的位置。</p>
<p>实际上，这个班的数学成绩一直是全校排名第一，但是刘老师认为，如果一直只看全校成绩，第一名的优越感容易让大家松懈下来，迟早会被人超越。所以，她自己设计了一种成绩表示，她称之为自比分。每次考试之后，根据全年级的平均分，确定这次考试的难度系数，然后将每个人的成绩统一到同一难度系数的分值下。然后每次考试的成绩都是这次考试对上次考试的分数差值。自比分强调每个人应该与自己做比较，正值说明你在进步，负值说明你在退步。而这次考试，除了胡梦，高忆和欧阳时，其他人都是负值。但是高忆和欧阳时是满分，而胡梦依旧是全班最后一名。</p>
<p>刘老师等着同学们寻找自己的名字，她环顾四周，看着大家脸上的表情。这时发现胡梦趴在那，大吼了一声，”胡梦”，胡梦猛的抬起了头，眼神充满着惊恐。”别以为你自比分高就心安理得了，你现在成绩还是全班最后一名，你努力的还不够。” 其实，胡梦并不知道自己的自比分到底是多少，听到刘老师这么一说，才看向投影里的成绩表，原来自己的自比分相较于上一次考试高了一个档位，在全校的排名也前进了一百多名。虽然刚刚被老师说了一通，但是看到这个分数心里还是很高兴的。</p>
<p>“好了，还想看成绩的同学下课再看，我们现在开始讲试卷，班长，把这些试卷发下去。”刘老师边说边把电脑上的表格文件关掉。李情旭走到老师旁边，拿走了一打试卷，分发给大家。</p>
<p>回到桌位上，李情旭看了一眼胡梦，胡梦拿到自己的试卷，嘟囔了一句:”这样真的有效。”，”什么有效？”李情旭很不解的看着她。”没啥”。胡梦抬起头，看向老师。而李情旭微微一笑，也转头看向了老师。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;small&gt;&lt;em&gt;总字数：1890字，阅读时间：约4分钟&lt;/em&gt;&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;老师伴着上课的曲子进门，班长李情旭看了一眼老师，扭头对同桌胡梦说：“这节课别睡觉了，刘老师心情很不好”。老师走上讲台，把考试卷子放在讲台桌子上，把U盘插在电脑上，像往常一样， 准备把上课的课件拷到电脑上。《土耳其进行曲》还在耳边回荡，也不清楚这所学校为什么要用这个曲子作为上课的铃声。估计是它的节奏比较欢快，能让人产生一种愉悦的心情以面对接下来四十五分钟的枯燥。老师还在操作着电脑，课间喧闹的气氛还没有消散，大家都七嘴八舌的讨论着。胡梦抬了抬头，看了看老师，像往常一样，没有任何的变化。胡梦又把头低了下来，枕在自己的手上。嘟囔了一句:“别闹”。李情旭也没有再理睡梦中的同桌，把目光转向投影出来的电脑画面。&lt;/p&gt;
    
    </summary>
    
      <category term="小说" scheme="https://arstead.github.io/categories/%E5%B0%8F%E8%AF%B4/"/>
    
      <category term="一个人的能力" scheme="https://arstead.github.io/categories/%E5%B0%8F%E8%AF%B4/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E8%83%BD%E5%8A%9B/"/>
    
    
      <category term="小说" scheme="https://arstead.github.io/tags/%E5%B0%8F%E8%AF%B4/"/>
    
  </entry>
  
  <entry>
    <title>序</title>
    <link href="https://arstead.github.io/Preface/"/>
    <id>https://arstead.github.io/Preface/</id>
    <published>2017-01-22T13:34:58.000Z</published>
    <updated>2017-02-06T18:44:30.398Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Hi-Thinking"><a href="#Hi-Thinking" class="headerlink" title="Hi, Thinking!"></a>Hi, Thinking!</h4><p>现实世界充满喧嚣，启程时的誓言已被掩盖。路途中四处观花，轻尝美景的芬芳。丽影无数，却只略观，此时想起回眸，不晚，不晚。<br>掩埋野蜂的狂浪，静坐思考，揭开藏在深处的远方。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Hi-Thinking&quot;&gt;&lt;a href=&quot;#Hi-Thinking&quot; class=&quot;headerlink&quot; title=&quot;Hi, Thinking!&quot;&gt;&lt;/a&gt;Hi, Thinking!&lt;/h4&gt;&lt;p&gt;现实世界充满喧嚣，启程时的誓言已被掩盖。路途中四处观花，轻尝
    
    </summary>
    
    
  </entry>
  
</feed>
