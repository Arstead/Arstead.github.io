<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>刚开始接触机器学习的时候，曾经试过用python写过一个简单的MLP（Multi-Layer Perceptron），其中仅仅只是实现了简单的Gradient descent算法，激活函数上也只涉及了Sigmod激活函数。在这之后的很多研究中，都是用的现成的算法库在跑，完全接触不到实现方法，编程能力也急剧下降。所以趁着现在有点时间，认真学习一下别人是怎么样实现深度学习方法的。由于我一直使用的是python语言，而且我在入门深度学习的时候也是从Keras这个库开始的。自从被TensorFlow列为官网API之后，Keras使用的人也极具上升。所以决定从Keras源码开始看起，学习一下别人是如何实现深度学习框架的。</p>
<p>由于我是即兴记录的，目前还没有任何的目标。所以可能会出现结构上有些凌乱，等我都掌握了之后，我再做整理吧。</p>
<h4 id="文档结构"><a href="#文档结构" class="headerlink" title="文档结构"></a>文档结构</h4><p>我们先来看看Keras下的文档结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">|-- docs                #说明文档</div><div class="line">|-- examples            #应用示例</div><div class="line">|-- test                #测试文件</div><div class="line">|-- keras               #源码核心</div><div class="line">|  |-- backend          #底层backend</div><div class="line">|  |-- datasets         #数据获取源码</div><div class="line">|  |-- engine           #核心工具</div><div class="line">|  |-- layers           #层源码</div><div class="line">|  |-- legacy           #遗留源码</div><div class="line">|  |-- preprocessing    #预处理函数</div><div class="line">|  |-- utils            #实用工具函数</div><div class="line">|  |-- wrappers         #scikit-learn 封装类</div><div class="line">|  |-- activations.py</div><div class="line">|  |-- callbacks.py</div><div class="line">|  |-- constraints.py</div><div class="line">|  |-- initializations.py</div><div class="line">|  |-- metrics.py</div><div class="line">|  |-- models.py</div><div class="line">|  |-- objectives.py</div><div class="line">|  |-- optimizers.py</div><div class="line">|  |-- regularizers.py</div></pre></td></tr></table></figure>
<p>实际上，对于在深度学习这个模块里面，我们主要关注的是engine文件夹中的内容，这里面包含了关于model、layer、node的实现方式，也就是最底层的内容。而我们在应用当中，主要使用的Keras文件夹下.py的文件，其中常用的Sequential模型在models.py中实现，各种Optimizer类在optimizers.py中实现，各种激活函数在activations.py等等。这些内容我们以后慢慢来看，我们先从底层开始看起，看看Keras的底层是如何实现可扩展结构的。</p>
<h4 id="backend"><a href="#backend" class="headerlink" title="backend"></a>backend</h4><p>Keras可以在两中backend下运行，一个是TensorFlow，另一个是Theano。这是Keras最底层的计算模块。使用这两个模块也让其能够很好的利用GPU的计算资源。</p>
<p>进入backend文件夹，下面有四个文件，__init__.py、common.py、tensorflow_backend.py和theano<em>backend.py。\</em>_init__.py用于引入backend时的初始化，所以决定具体使用的是哪个backend应该是由这里面的代码来决定的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">_keras_base_dir = os.path.expanduser(&apos;~&apos;)</div><div class="line">if not os.access(_keras_base_dir, os.W_OK):</div><div class="line">    _keras_base_dir = &apos;/tmp&apos;</div><div class="line"></div><div class="line">_keras_dir = os.path.join(_keras_base_dir, &apos;.keras&apos;)</div><div class="line">if not os.path.exists(_keras_dir):</div><div class="line">    os.makedirs(_keras_dir)</div><div class="line"></div><div class="line">_BACKEND = &apos;theano&apos;</div><div class="line">_config_path = os.path.expanduser(os.path.join(_keras_dir, &apos;keras.json&apos;))</div></pre></td></tr></table></figure>
<p>在这些代码中我们可以看到，需要获取用户目录下.keras中keras.json的文件夹，这个文件中包含了我们关于backend的相关配置。下面是我的电脑中keras.json文件的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;floatx&quot;: &quot;float32&quot;,</div><div class="line">    &quot;backend&quot;: &quot;tensorflow&quot;,</div><div class="line">    &quot;epsilon&quot;: 1e-07,</div><div class="line">    &quot;image_dim_ordering&quot;: &quot;tf&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果这个文件存在话，Keras就会调用这个文件中的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">if os.path.exists(_config_path):</div><div class="line">    _config = json.load(open(_config_path))</div><div class="line">    _floatx = _config.get(&apos;floatx&apos;, floatx())</div><div class="line">    assert _floatx in &#123;&apos;float16&apos;, &apos;float32&apos;, &apos;float64&apos;&#125;</div><div class="line">    _epsilon = _config.get(&apos;epsilon&apos;, epsilon())</div><div class="line">    assert type(_epsilon) == float</div><div class="line">    _backend = _config.get(&apos;backend&apos;, _BACKEND)</div><div class="line">    assert _backend in &#123;&apos;theano&apos;, &apos;tensorflow&apos;&#125;</div><div class="line">    _image_dim_ordering = _config.get(&apos;image_dim_ordering&apos;, image_dim_ordering())</div><div class="line">    assert _image_dim_ordering in &#123;&apos;tf&apos;, &apos;th&apos;&#125;</div><div class="line"></div><div class="line">    set_floatx(_floatx)</div><div class="line">    set_epsilon(_epsilon)</div><div class="line">    _BACKEND = _backend</div></pre></td></tr></table></figure>
<p>Keras会读取keras.json中的配置信息，然后验证其合法性。然后进行相关的设置。注意：floatx()、epsilon()、set_floatx(_floatx)、set_epsilon(_epsilon)都是common.py文件中定义的函数。在common.py文件中定义了这几个参数的默认值。如果不存在keras.json文件时，或部分参数缺失时，Keras就会使用默认值进行设置，否则就通过keras.json中的参数来修改common.py定义的值。不过这里就有一个疑问了，为什么_BACKEND没有定义在common.py中而要在这里单独定义？略显奇怪，可能看之后的代码能得到解决吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">_config = &#123;&apos;floatx&apos;: floatx(),</div><div class="line">           &apos;epsilon&apos;: epsilon(),</div><div class="line">           &apos;backend&apos;: _BACKEND,</div><div class="line">           &apos;image_dim_ordering&apos;: image_dim_ordering()&#125;</div><div class="line">with open(_config_path, &apos;w&apos;) as f:</div><div class="line">    f.write(json.dumps(_config, indent=4))</div></pre></td></tr></table></figure>
<p>在完成了对参数的检查之后，Keras将合法化后的参数在重新保存会配置文件之中。这种方式保证了在每次使用之后都能留有合法的配置，而且都能保留上一次的配置内容。不过我确实没有看出写回的必要性。如果参数缺省，上面的合法检验会保证使用默认参数，那么就算不写回，每次使用的也都是默认参数（即上一次的配置内容）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if &apos;KERAS_BACKEND&apos; in os.environ:</div><div class="line">    _backend = os.environ[&apos;KERAS_BACKEND&apos;]</div><div class="line">    assert _backend in &#123;&apos;theano&apos;, &apos;tensorflow&apos;&#125;</div><div class="line">    _BACKEND = _backend</div></pre></td></tr></table></figure>
<p>接下来是看系统信息中是否包含backend相关参数，如果存在，则使用系统的参数。在这里我们可以看到，在backend的使用优先级：系统配置&gt;用户配置&gt;默认配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">if _BACKEND == &apos;theano&apos;:</div><div class="line">    sys.stderr.write(&apos;Using Theano backend.\n&apos;)</div><div class="line">    from .theano_backend import *</div><div class="line">elif _BACKEND == &apos;tensorflow&apos;:</div><div class="line">    sys.stderr.write(&apos;Using TensorFlow backend.\n&apos;)</div><div class="line">    from .tensorflow_backend import *</div><div class="line">else:</div><div class="line">    raise Exception(&apos;Unknown backend: &apos; + str(_BACKEND))</div></pre></td></tr></table></figure>
<p>最后是根据配置情况，导入最终的backend，并给出反馈。可以看出作者在最开始写这部分代码的时候特别的谨慎，存在大量的合法性检验。</p>
<p>在tensorflow_backend.py和theano_backend.py文件中是包含了各种基本运算的两种不同实现方式，其提供的接口是一模一样的，有兴趣的是可以看一下。在common.py文件中包含的是关于默认参数的设置，值得一提的是下面这个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def get_uid(prefix=&apos;&apos;):</div><div class="line">    if prefix not in _UID_PREFIXES:</div><div class="line">        _UID_PREFIXES[prefix] = 1</div><div class="line">        return 1</div><div class="line">    else:</div><div class="line">        _UID_PREFIXES[prefix] += 1</div><div class="line">        return _UID_PREFIXES[prefix]</div></pre></td></tr></table></figure>
<p>这个函数在后面各种各样的类中定义name变量时都被调用了。这个函数是用来保证在其后定义其他类的时候，使用默认name变量时不出现重名的情况。因为Keras在后面搜索layer对象等其他对象时，都是依据name变量的值来保证唯一性。而所以在这里定义了一个函数，其后的类在定义的时候如果没有设置name变量，这会使用’class_name’ + get_uid(‘class_name’)的方式来定义name。</p>
<h4 id="layer"><a href="#layer" class="headerlink" title="layer"></a>layer</h4><p>layer类是Keras最为重要的一个类，因为这个类构成了整个Keras的核心骨架。这个类在engine文件夹下的topology.py中定义。看这个文件之前，我们先看看engine文件夹下的__init__.py文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># note: topology.Node is an internal class,</div><div class="line"># it isn&apos;t meant to be used by Keras users.</div><div class="line">from .topology import InputSpec</div><div class="line">from .topology import Input</div><div class="line">from .topology import InputLayer</div><div class="line">from .topology import Layer</div><div class="line">from .topology import Merge</div><div class="line">from .topology import merge</div><div class="line">from .topology import get_source_inputs</div><div class="line">from .training import Model</div></pre></td></tr></table></figure>
<p>之所以看这个文件的主要原因是，这个文件是在engine在被import时会被引入的函数。这决定了在topology.py和training.py两个文件中，哪些函数是被外部所使用，哪些函数是内部的支持函数。我们将这个列表保留在这，方便之后查看。</p>
